<apex:component controller="sma.JSMapAnythingPlotting" >
    
    <script>
        //styled markers, this can probably be moved to the static resource once done changing it to fit our needs. 
    
        var StyledIconTypes = {};
        var StyledMarker, StyledIcon;
        
        /**
         * @param {Function} childCtor Child class.
         * @param {Function} parentCtor Parent class.
         */
        function inherits(childCtor, parentCtor) {
          /** @constructor */
          function tempCtor() {};
          tempCtor.prototype = parentCtor.prototype;
          childCtor.superClass_ = parentCtor.prototype;
          childCtor.prototype = new tempCtor();
          /** @override */
          childCtor.prototype.constructor = childCtor;
        }
         
        (function() {
          var bu_ = 'https://chart.googleapis.com/chart?chst=';
          var gm_ = google.maps;
          var gp_ = gm_.Point;
          var ge_ = gm_.event;
          var gmi_ = gm_.MarkerImage;
          
        
          /**
          * This class is an extended version of google.maps.Marker. It allows
          * styles to be applied that change it's appearance.
          * @extends google.maps.Marker
          * @param {StyledMarkerOptions} StyledMarkerOptions The options for the Marker
          */
          StyledMarker = function(styledMarkerOptions) {
            gm_.Marker.call(this);
            var me=this;
            var ci = me.styleIcon = styledMarkerOptions.styleIcon;
            me.bindTo('icon',ci);
            me.bindTo('shadow',ci);
            me.bindTo('shape',ci);
            me.setOptions(styledMarkerOptions);
          };
          inherits(StyledMarker, gm_.Marker);
          
          /**
          * This class stores style information that can be applied to StyledMarkers.
          * @extends google.maps.MVCObject
          * @param {StyledIconType} styledIconType The type of style this icon is.
          * @param {StyledIconOptions} styledIconOptions The options for this StyledIcon.
          * @param {StyledIcon} styleClass A class to apply extended style information.
          */
          StyledIcon = function(styledIconType,styledIconOptions,styleClass) {
            var k;
            var me=this;
            var i_ = 'icon';
            var sw_ = 'shadow';
            var s_ = 'shape';
            var a_ = [];
        
            function gs_() {
              var image_ = document.createElement('img');
              var simage_ = document.createElement('img');
              ge_.addDomListenerOnce(simage_, 'load', function() {
                var w = simage_.width, h = simage_.height;
                me.set(sw_,new gmi_(styledIconType.getShadowURL(me),null,null,styledIconType.getShadowAnchor(me,w,h)));
                simage = null;
              });
              ge_.addDomListenerOnce(image_, 'load', function() {
                var w = image_.width, h = image_.height;
                me.set(i_,new gmi_(styledIconType.getURL(me),null,null,styledIconType.getAnchor(me,w,h)));
                me.set(s_,styledIconType.getShape(me,w,h));
                image_ = null;
              });
              image_.src = styledIconType.getURL(me);
              simage_.src = styledIconType.getShadowURL(me);
            }
        
            /**
            * set:
            * This function sets a given style property to the given value.
            * @param {String} name The name of the property to set.
            * @param {Object} value The value to set the property to.
            * get:
            * This function gets a given style property.
            * @param {String} name The name of the property to get.
            * @return {Object}
            */
            me.as_ = function(v) {
              a_.push(v);
              for(k in styledIconOptions) {
                v.set(k, styledIconOptions[k]);
              }
            }
        
            if (styledIconType !== StyledIconTypes.CLASS) {
              for (k in styledIconType.defaults) {
                me.set(k, styledIconType.defaults[k]);
              }
              me.setValues(styledIconOptions);
              me.set(i_,styledIconType.getURL(me));
              me.set(sw_,styledIconType.getShadowURL(me));
              if (styleClass) styleClass.as_(me);
              gs_();
              me.changed = function(k) {
                if (k!==i_&&k!==s_&&k!==sw_) {
                  gs_();
                }
              };
            } else {
              me.setValues(styledIconOptions);
              me.changed = function(v) {
                styledIconOptions[v] = me.get(v);
                for (k = 0; k < a_.length; k++) {
                  a_[k].set(v,me.get(v));
                }
              };
              if (styleClass) styleClass.as_(me);
            }
          };
          StyledIcon.prototype = new gm_.MVCObject();
          
          /**
          * StyledIconType
          * This class holds functions for building the information needed to style markers.
          * getURL:
          * This function builds and returns a URL to use for the Marker icon property.
          * @param {StyledIcon} icon The StyledIcon that holds style information
          * @return {String}
          * getShadowURL:
          * This function builds and returns a URL to use for the Marker shadow property.
          * @param {StyledIcon} icon The StyledIcon that holds style information
          * @return {String{
          * getAnchor:
          * This function builds and returns a Point to indicate where the marker is placed.
          * @param {StyledIcon} icon The StyledIcon that holds style information
          * @param {Number} width The width of the icon image.
          * @param {Number} height The height of the icon image.
          * @return {google.maps.Point}
          * getShadowAnchor:
          * This function builds and returns a Point to indicate where the shadow is placed.
          * @param {StyledIcon} icon The StyledIcon that holds style information
          * @param {Number} width The width of the shadow image.
          * @param {Number} height The height of the shadow image.
          * @return {google.maps.Point}
          * getShape:
          * This function builds and returns a MarkerShape to indicate where the Marker is clickable.
          * @param {StyledIcon} icon The StyledIcon that holds style information
          * @param {Number} width The width of the icon image.
          * @param {Number} height The height of the icon image.
          * @return {google.maps.MarkerShape}
          */
          
          StyledIconTypes.CLASS = {};
          
          StyledIconTypes.MARKER = {
            defaults: {
              text:'',
              color:'00ff00',
              fore:'000000',
              starcolor:null
            },
            getURL: function(props){
              var _url;
              var starcolor_=props.get('starcolor');
              var text_=props.get('text');
              var color_=props.get('color').replace(/#/,'');
              var fore_=props.get('fore').replace(/#/,'');
              if (starcolor_) {
                _url = bu_ + 'd_map_xpin_letter&chld=pin_star|';
              } else {
                _url = bu_ + 'd_map_pin_letter&chld=';
              }
              if (text_) {
                text_ = text_.substr(0,2);
              }
              _url+=text_+'|';
              _url+=color_+'|';
              _url+=fore_;
              if (starcolor_) {
                _url+='|'+starcolor_.replace(/#/,'');
              }
              return _url;
            },
            getShadowURL: function(props){
              if (props.get('starcolor')) {
                return bu_ + 'd_map_xpin_shadow&chld=pin_star';
              } else {
                return bu_ + 'd_map_pin_shadow';
              }
            },
            getAnchor: function(props,width,height){
              return new gp_(width / 2,height);
            },
            getShadowAnchor: function(props,width,height){
              return new gp_(width / 4,height);
            },
            getShape: function(props,width,height){
              var _iconmap = {};
              _iconmap.coord = [
                width / 2, height,
                (7 / 16) * width, (5 / 8) * height,
                (5 / 16) * width, (7 / 16) * height,
                (7 / 32) * width, (5 / 16) * height,
                (5 / 16) * width, (1 / 8) * height,
                (1 / 2) * width, 0,
                (11 / 16) * width, (1 / 8) * height,
                (25 / 32) * width, (5 / 16) * height,
                (11 / 16) * width, (7 / 16) * height,
                (9 / 16) * width, (5 / 8) * height
              ];
              for (var i = 0; i < _iconmap.coord.length; i++) {
                _iconmap.coord[i] = Math.round(_iconmap.coord[i]);
              }
              _iconmap.type = 'poly';
              return _iconmap;
            }
          };
          StyledIconTypes.BUBBLE = {
            defaults: {
              text:'',
              color:'00ff00',
              fore:'000000'
            },
            getURL: function(props){
              var _url = bu_ + 'd_bubble_text_small&chld=bb|';
              _url+=props.get('text')+'|';
              _url+=props.get('color').replace(/#/,'')+'|';
              _url+=props.get('fore').replace(/#/,'');
              return _url;
            },
            getShadowURL: function(props){
              return bu_ + 'd_bubble_text_small_shadow&chld=bb|' + props.get('text');
            },
            getAnchor: function(props,width,height){
              return new google.maps.Point(0,42);
            },
            getShadowAnchor: function(props,width,height){
              return new google.maps.Point(0,44);
            },
            getShape: function(props,width,height){
              var _iconmap = {};
              _iconmap.coord = [
                0,44,
                13,26,
                13,6,
                17,1,
                width - 4,1,
                width,6,
                width,21,
                width - 4,26,
                21,26
              ];
              _iconmap.type = 'poly';
              return _iconmap;
            }
          };
        })();
        
    </script>

	<script type='text/javascript'>
		//set global index for unique checkboxes
		var queryIndex = 0;

	
		function analyzeQuery(options)
		{
			queryIndex++;
			
			//default options
			options = $.extend({
				includeMetadata: true,
				includeData: true,
				showDistanceLimit: true,
				destructive: true
			}, options || {});
			
			//init old parameters (moving to an options model, but I don't want to change all the code below so I'm creating these)
			var $plottedQuery = options.plottedQuery;
			var callback = options.callback;
			
			//initialize query records
			$plottedQuery.data('records', {});
			
			//if this query is for the visible area only, we need to send some additional map data with the request
			var requestData = { visibleAreaOnly: false, includeMetadata: options.includeMetadata, includeData: options.includeData, offset: 0 };
			if ($plottedQuery.data('visibleAreaOnly'))
			{
				var mapBounds = MA.map.getBounds();
				$.extend(requestData, {
					visibleAreaOnly	: true,
					mapLat			: MA.map.getCenter().lat(),
					mapLong			: MA.map.getCenter().lng(),
					mapHeight		: Math.abs(mapBounds.getNorthEast().lat() - mapBounds.getSouthWest().lat()),
					mapWidth		: Math.abs(mapBounds.getNorthEast().lng() - mapBounds.getSouthWest().lng())
				});
			}
			
			//if this isn't an actual saved query, we need to send query metadata
			if ($plottedQuery.data('savedQueryId')) {
				requestData.savedQueryId = $plottedQuery.data('savedQueryId');
			}
			else {
				$.extend(requestData, {
					BaseObjectId		: $plottedQuery.data('baseObjectId'),
					recordIds			: $plottedQuery.data('recordIds').join(','),
					markerColor			: $plottedQuery.data('markerColor'),
					tooltipFieldsString	: $plottedQuery.data('tooltipFields').join(',')
				});
			}
			
			//if NearBy query, add limit
			if(options.limit)
			{
				$.extend(requestData, {
					limit: options.limit
				});
			}
			
			//send request for query analysis
			$.getJSON(MA.resources.Query+pageSuffix+"?action=analyze_query&UserId=" + UserId, requestData, function handleResponse (response) {
		        if (response.success)
		        {
		        	//store metadata if it was requested
		        	if (requestData.includeMetadata)
		        	{
			        	//update the plotted query row
			        	$plottedQuery.find('.title').text(response.data.savedQueryName);
	    				$plottedQuery.find('.subtitle').text(response.data.baseObjectLabel);
			        
			        	//store basic info
			        	$plottedQuery.data({
			        		baseObjectId		: response.data.BaseObjectId,
			        		savedQueryName		: response.data.savedQueryName,
	                		baseObjectName		: response.data.baseObjectName,
	                		baseObjectLabel		: response.data.baseObjectLabel,
	                		baseObjectSettings	: response.data.baseObjectSettings,
			        		relatedListCount	: response.data.relatedListCount,
			        		refreshInterval		: response.data.refreshInterval,
			        		supportsActivities	: response.data.supportsActivities,
			        		supportsCurrencies	: response.data.supportsCurrencies,
			        		supportsChatter		: response.data.supportsChatter,
			        		permissions			: removeNamespace(MA.Namespace, response.data.permissions)
			        	});
			        	
			        	//store the advance options
			        	if (response.data.advancedOptions) {
			        		$plottedQuery.data('advancedOptions', {
			        			address				: response.data.advancedOptions.address,
			        			distance			: response.data.advancedOptions.distance,
			        			enableLimit			: response.data.advancedOptions.enableLimit == 'true',
			        			enableProxLimit		: response.data.advancedOptions.enableProxLimit == 'true',
			        			aggregateType		: response.data.advancedOptions.aggregateType && response.data.advancedOptions.aggregateType != '' ? response.data.advancedOptions.aggregateType : '',
			        			selectType			: response.data.advancedOptions.selectType,
			        			defaultTab			: response.data.advancedOptions.defaultTab || 'info',
			        			defaultRenderMode	: response.data.advancedOptions.defaultRenderMode || 'Default',
			        			distanceMinLat		: response.data.advancedOptions.distanceMinLat,
				            	distanceMaxLat 		: response.data.advancedOptions.distanceMaxLat,
						       	distanceMinLong		: response.data.advancedOptions.distanceMinLong,
						       	distanceMaxLong 	: response.data.advancedOptions.distanceMaxLong,
						       	all                 : response.data.advancedOptions
			        		});
			        	}
			        	
			        	//draw a circle to represent distance limit if it is used
			        	if (options.showDistanceLimit && response.data.advancedOptions && response.data.advancedOptions.enableProxLimit == 'true')
			        	{
			        		$plottedQuery.data('distanceLimitCircle', new google.maps.Circle({
		                        map: MA.map,
								center: new google.maps.LatLng(parseFloat(response.data.advancedOptions.distanceLat), parseFloat(response.data.advancedOptions.distanceLong)),
								radius: parseFloat(response.data.advancedOptions.distanceMeters),
								layerType: 'prox',
								strokeColor: '#FF0000',
								strokeWeight: 3,
								strokeOpacity: 1,
		                        fillOpacity: 0,
		                        zIndex: -999
							}));
						}
			        	
			        	//store the proximity options
			        	if (response.data.proximityOptions) {
			        		$plottedQuery.data('proximityOptions', {
			        			enabled			: response.data.proximityOptions.enabled == 'true',
			        			hideMarkers		: response.data.proximityOptions.hideMarkers == 'true',
			        			affectVisibility: response.data.proximityOptions.affectVisibility != 'false',
			        			radius			: response.data.proximityOptions.radius,
			        			measurementType	: response.data.proximityOptions.measurementType,
			        			selectType		: response.data.proximityOptions.selectType,
			        			mode			: response.data.proximityOptions.mode,
			        			unitType		: response.data.proximityOptions.unitType,
			        			traffic			: response.data.proximityOptions.traffic  == 'true' ? 'enabled' : 'disabled',
			        			fill            : (response.data.proximityOptions.fill) ? response.data.proximityOptions.fill : '#223388',
                                border          : (response.data.proximityOptions.border) ? response.data.proximityOptions.border : '#882233',
                                opacity         : (response.data.proximityOptions.opacity) ? response.data.proximityOptions.opacity : '0.60'
			        		});
			        	}
			        	
			        	//store the marker metadata that was returned
			        	$plottedQuery.data('markerMetadata', response.data.markerMetadata);
			        	
			        	//process the color/image assignments (keep track of any images that are used so we can preload them)
			        	$plottedQuery.data('imgIds', []);
			        	var imgIds = $plottedQuery.data('imgIds');
			        	if (response.data.markerMetadata.ColorAssignmentType == 'Static')
			        	{
			        		//this is a static assignment so just record the img id if we have one
			        		if (response.data.markerMetadata.IconColor && response.data.markerMetadata.IconColor.indexOf('image:') == 0)
	                        {
	                            imgIds.push(response.data.markerMetadata.IconColor.split('image:')[1]);
	                        }
			        	}
			        	else if (response.data.markerMetadata.ColorAssignmentType == 'Dynamic, Field')
			        	{
			        		var markerMetadata = $plottedQuery.data('markerMetadata');
			        		
			        		//append icon to $plottedQuery
			        		$plottedQuery.find('.color-box').addClass('dynamic queryIcon').css('display','none');

			        		//Legacy support for new marker format
			        		try
			        		{
			        			markerMetadata.colorAssignmentrules = JSON.parse(markerMetadata.ColorAssignment);
			        		}
			        		catch (err) 
			        		{
			        			var colorAssignmentArr = [];
           						$.each(markerMetadata.ColorAssignment.split('~~'), function (index, colorAssignment) {
           							if (colorAssignment != '')
           							{
           								var assignmentParts = colorAssignment.split('~');
	           							colorAssignmentArr.push({
							           		operator 		: 'equals',
							           		comparevalue	: assignmentParts[0],
							           		value 			: assignmentParts[1]
						           		});
           							}
           						});
           						markerMetadata.colorAssignmentrules = colorAssignmentArr;
			        		}
			        		
			        		//add each color assignment to our marker metadata and also to the legend
			        		markerMetadata.ColorAssignments = {};
			            	$.each(markerMetadata.colorAssignmentrules, function (index, rule) {
			            	
			            		//record the img id for this assignment if we have one
			            		var imgId = '';
		            			if (rule.value.indexOf('image:') == 0)
		                        {
		                        	imgId = rule.value.split('image:')[1];
		                            imgIds.push(imgId);
		                        }
		                        
		                        //start building a new legend row for this assignment based on field selection
		                        if(rule.operator == 'currency')
		            			{
		            				//format currency options for shorthand
			                        var currencyMap = {
			                        	0	: '',
			                        	1	: 'k',
										2	: 'M',
										3	: 'B',
										4	: 'T',
										5	: 'Q'
									};
									
									//format the to value
									var toIndex = 0;
			                        var toval = rule.toVal.replace(/,/g, '');
			                        if(toval != '' && toval != '<Other>' && toval > 0 && (toval % 1 != 0) == false)
			                        {
			                        	//this is a positive whole number, simplify it
			                        	toval = toval/1;
				                        while (toval >= 1000) {
				                        	toval = (toval/1000).toFixed(2) * 1;
				                        	toIndex++;
				                        }
				                        toval = (toval.toFixed(2) * 1).toString() + currencyMap[toIndex];
			                        }
			                        else if(toval != '' && toval != '<Other>' && toval < 0 && (toval % 1 != 0) == false)
			                        {
			                        	//this is a negative whole number, simplify it
			                        	toval = toval/1;
			                        	while (toval <= -1000)
				                        {
				                        	toval = (toval/1000).toFixed(2) * 1;
				                        	toIndex++;
				                        }
				                        toval = (toval.toFixed(2) * 1).toString() + currencyMap[toIndex];
			                        }
			                        var currencyType = userSettings.userCurrency != undefined ? userSettings.userCurrency+ ' ' : '$';
			                        toval = (markerMetadata.PicklistFieldType == 'CURRENCY' ? currencyType : '') + toval;
			                        
			                        //format the from value
			                        var fromIndex = 0;
			                        var fromval = rule.comparevalue.replace(/,/g, '');
			                        if(fromval != '' && fromval != '<Other>' && fromval > 0 && (fromval % 1 != 0) == false)
			                        {
			                        	//this is a positive whole number, simplify it
			                        	fromval = fromval/1;
				                        while (fromval >= 1000) {
				                        	fromval = (fromval/1000).toFixed(2) * 1;
				                        	fromIndex++;
				                        }
				                        fromval = (fromval.toFixed(2) * 1).toString() + currencyMap[fromIndex];
			                        }
			                        else if(fromval != '' && fromval != '<Other>' && fromval < 0 && (fromval % 1 != 0) == false)
			                        {
			                        	//this is a negative whole number, simplify it
			                        	fromval = fromval/1;
			                        	while (fromval <= -1000) {
				                        	fromval = (fromval/1000).toFixed(2) * 1;
				                        	fromIndex++;
				                        }
				                        fromval = (fromval.toFixed(2) * 1).toString() + currencyMap[fromIndex];
			                        }
			                        var currencyType = userSettings.userCurrency != undefined ? userSettings.userCurrency+ ' ' : '$';
			                        fromval = (markerMetadata.PicklistFieldType == 'CURRENCY' ? currencyType : '') + fromval;
			                        
			                        //build the legend row
		            				if(rule.comparevalue == '<Other>')
		            				{
		            					var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(rule.comparevalue))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            				else if(rule.comparevalue == '')
		            				{
		            					var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(toval + ' ' + 'and lower'))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            				else if(rule.toVal == '')
		            				{
		            					var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(fromval + ' ' + 'and higher'))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            				else
		            				{
				                        var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(fromval + ' ' + 'to' + ' ' + toval))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            			}
		            			else if(rule.comparedisplay != null)
		            			{
		            				var $newLegendRow = $(
			            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
			            				.replace(/::AssignmentRule::/g, htmlEncode(index))
			            				.replace(/::AssignmentValue::/g, htmlEncode(rule.comparedisplay))
			            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
			            			).data('numMarkers', 0);
		            			}
		            			else if(rule.operator == 'includes')
		            			{
		            				if(rule.comparevalue == '<Other>')
		            				{
		            					var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(rule.comparevalue))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            				else
		            				{
			            				//format results for multipicklist 
			            				var results = rule.comparevalue.split('~~');
			            				if(results.length > 2)
			            				{
			            					results = ''+results.length+' options included';
			            				}
			            				else
			            				{
			            					var toStringResults = String(results)
			            					results = 'Includes '+toStringResults+'';
			            				}
			            				var $newLegendRow = $(
				            				"<tr Title='::hoverInfo::' class='legend-row' style='display: none;'><td><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(results))
				            				.replace(/::hoverInfo::/g, htmlEncode(rule.comparevalue.split('~~')))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
				            		}
		            			}
		            			else if(rule.operator == 'excludes')
		            			{
		            				//format results for multipicklist 
		            				var results = rule.comparevalue.split('~~');
		            				if(results.length > 2)
		            				{
		            					results = ''+results.length+' options excludeded';
		            				}
		            				else
		            				{
		            					var toStringResults = String(results)
		            					results = 'Excludes '+toStringResults+'';
		            				}
		            				var $newLegendRow = $(
			            				"<tr Title='::hoverInfo::' class='legend-row' style='display: none;'><td><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
			            				.replace(/::AssignmentRule::/g, htmlEncode(index))
			            				.replace(/::AssignmentValue::/g, htmlEncode(results))
			            				.replace(/::hoverInfo::/g, htmlEncode(rule.comparevalue.split('~~')))
			            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
			            			).data('numMarkers', 0);
		            			}
		            			else if(rule.operator == 'date')
		            			{
									//capitalize for moment
									var formatedDate = formatUserLocaleDate({datepicker:true}).replace('mm','MM').replace('dd','DD').replace('yy','YYYY');
									
									var formatCompareValue;
									var formatEndDate;
									var comparevalueIsDateLiteral;
									var enddateIsDateLiteral;
									
									//check for date literals
				            		for (var i in MADateLiterals)
				                    {
				                        //check if the label matches and the value is not blank (blank value denotes a dynamic date literal and cannot be matched directly)
				                        if (MADateLiterals[i].label == rule.comparevalue && MADateLiterals[i].value != 'DYNAMIC')
				                        {
				                        	formatCompareValue = rule.comparevalue;
				                        	comparevalueIsDateLiteral = true;
				                        	
				                        }
				                        if (MADateLiterals[i].label == rule.enddate && MADateLiterals[i].value != 'DYNAMIC')
				                        {
				                        	formatEndDate = rule.enddate;
				                        	enddateIsDateLiteral = true;
				                        }
				                    }
									
									//check if the from value is a dynamic date literal
				                    try {
				                        var stringParts = rule.comparevalue.split(' ');
				                        if (stringParts[0] == 'NEXT' || stringParts[0] == 'LAST') {
				                        	if (!isNaN(parseInt(stringParts[1])) && stringParts.length == 3 && $.inArray(stringParts[2], ['DAYS', 'QUARTERS', 'YEARS']) != -1) {
				                        		formatCompareValue = rule.comparevalue;
				                        		comparevalueIsDateLiteral = true;
						                    }
				                        }
				                        else if (stringParts[2] == 'AGO' || stringParts[2] == 'FROM') {
				                        	var stringPartsValue = parseInt(stringParts[0]);
				                        	var stringPartsUnit = stringParts[1].toLowerCase();
				                        	if (!isNaN(stringPartsValue) && $.inArray(stringPartsUnit, ['days', 'years']) != -1) {
				                        		formatCompareValue = rule.comparevalue;
				                        		comparevalueIsDateLiteral = true;
				                        	}
					                    }
				                    }
				                    catch (err) { }
				                    
				                    //check if the to value is a dynamic date literal
				                    try {
				                        var stringParts = rule.enddate.split(' ');
				                        if (stringParts[0] == 'NEXT' || stringParts[0] == 'LAST') {
				                        	if (!isNaN(parseInt(stringParts[1])) && stringParts.length == 3 && $.inArray(stringParts[2], ['DAYS', 'QUARTERS', 'YEARS']) != -1) {
				                        		enddateIsDateLiteral = true;
				                        		formatEndDate = rule.enddate;
						                    }
				                        }
				                        else if (stringParts[2] == 'AGO' || stringParts[2] == 'FROM') {
				                        	var stringPartsValue = parseInt(stringParts[0]);
				                        	var stringPartsUnit = stringParts[1].toLowerCase();
				                        	if (!isNaN(stringPartsValue) && $.inArray(stringPartsUnit, ['days', 'years']) != -1) {
				                        		enddateIsDateLiteral = true;
				                        		formatEndDate = rule.enddate;
				                        	}
					                    }
				                    }
				                    catch (err) { }
									
									//format date to display correct user locale
									if(enddateIsDateLiteral != true || comparevalueIsDateLiteral != true)
									{
										formatCompareValue = moment(rule.comparevalue,'YYYY-MM-DD').format(formatedDate);
										formatEndDate = moment(rule.enddate,'YYYY-MM-DD').format(formatedDate);
									}
		            				if(rule.comparevalue == '<Other>')
		            				{
		            					var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(rule.comparevalue))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            				else if (rule.comparevalue == rule.enddate)
		            				{
		            					var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(formatCompareValue))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            				else
		            				{
		            					//default value for the legend item
		            					var assignmentValue = formatCompareValue + ' to ' + formatEndDate;
		            					
		            					//try to shorten the legend item by comparing date literals
		            					try 
		            					{
		            						var compareValueParts = rule.comparevalue.split(' ');
		            						var endDateParts = rule.enddate.split(' ');
		            						if (compareValueParts.length > 2 && endDateParts.length > 2) 
		            						{
		            							//both values are date literals so we might be able to shorten the legend item
		            							if ($.inArray(compareValueParts[0], ['NEXT', 'LAST']) != -1 && $.inArray(endDateParts[0], ['NEXT', 'LAST']) != -1)
		            							{
		            								//both are next/last date literals
		            								if (compareValueParts[0] == endDateParts[0] && compareValueParts[2] == endDateParts[2])
			            							{
			            								assignmentValue = compareValueParts[0] + ' ' + compareValueParts[1] + ' to ' + endDateParts[1] + ' ' + compareValueParts[2];
			            							}	
		            							}
		            							else if ($.inArray(compareValueParts[2], ['AGO', 'FROM']) != -1 && $.inArray(endDateParts[2], ['AGO', 'FROM']) != -1)
		            							{
		            								//both are ago/from now date literals
		            								var compareValueEnd = compareValueParts[2] + (compareValueParts[3] ? compareValueParts[3] : '');
		            								var endDateEnd = endDateParts[2] + (endDateParts[3] ? endDateParts[3] : '');
		            								if (compareValueEnd == endDateEnd && compareValueParts[1] == endDateParts[1])
		            								{
		            									if (compareValueEnd == 'AGO') {
		            										assignmentValue = endDateParts[0] + ' to ' + compareValueParts[0] + ' ' + compareValueParts[1] + ' AGO';
		            									}
		            									else {
		            										assignmentValue = compareValueParts[0] + ' to ' + endDateParts[0] + ' ' + compareValueParts[1] + ' FROM NOW';
		            									}
		            								}
		            							}
		            						}
		            						else if (rule.comparevalue == '' && rule.enddate == '')
		            						{
		            							assignmentValue = 'Everything';
		            						}
		            						else if (rule.comparevalue == '')
		            						{
		            							assignmentValue = rule.enddate + ' and earlier';
		            						}
		            						else if (rule.enddate == '')
		            						{
		            							assignmentValue = rule.comparevalue + ' and later';
		            						}
		            					}
		            					catch (err) { }
		            				
		            					//build the legend row
		            					var $newLegendRow = $(
				            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
				            				.replace(/::AssignmentRule::/g, htmlEncode(index))
				            				.replace(/::AssignmentValue::/g, htmlEncode(assignmentValue))
				            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
				            			).data('numMarkers', 0);
		            				}
		            			}
		            			else
		            			{
		            				var $newLegendRow = $(
			            				"<tr class='legend-row' style='display: none;'><td class='legend-checkbox-wrapper'><input type='checkbox' class='legend-checkbox' checked='checked' id='::AssignmentCheckID::' data-rule='::AssignmentRule::' /><label for='::AssignmentCheckID::'></label></td><td class='legend-text'>::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color'></td></tr>"
			            				.replace(/::AssignmentRule::/g, htmlEncode(index))
			            				.replace(/::AssignmentValue::/g, htmlEncode(rule.comparevalue))
			            				.replace(/::AssignmentCheckID::/g, htmlEncode('legend-checkbox-'+MA.componentIndex++))
			            			).data('numMarkers', 0);
		            			}
		            			
		            			//add legend icon (image or svg)
		            			if (imgId != '')
		            			{
		            				$newLegendRow.find('.legend-color').addClass('image').html('<img src="'+MA.SitePrefix+'/servlet/servlet.FileDownload?file='+imgId+'" style="height: 20px; max-width: 30px;" />');
		            			}
		            			else {
		            				$newLegendRow.find('.legend-color').attr('data-color', rule.value).html(MA.Marker.createSVG({ color: rule.value, forLegend: true }));
		            			}
		                        
			            		//add this legend row to the legend
			            		if (rule.comparevalue == '<Other>')
			            		{
			            			//this color is to be used for values that don't match an option.  store it separately
			            			markerMetadata.IconColorOther = rule.value;
			            			$plottedQuery.find('table.legend').append($newLegendRow.addClass('other'));
			            		}
			            		else
			            		{
			            			//add this value/color pair to the assignments
			            			markerMetadata.ColorAssignments[rule.comparevalue] = rule.value;
			            			$plottedQuery.find('table.legend').append($newLegendRow);
			            		}
		            			
			            	});
			            	
			            	//show the legend
			            	$plottedQuery.find('.legend').show();
			            	
			            	//click legend row to show hide markers
	            			$plottedQuery.find('.legend .legend-row').on('click', function () {  
							    $(this).find('.legend-checkbox').attr('checked', !$(this).find('.legend-checkbox').is(':checked')).change();
							});
			        	}
			        	
			        	//store the field info that was returned
			        	$plottedQuery.data('addressFields', response.data.addressFields);
			        	$plottedQuery.data('coordinateFields', response.data.coordinateFields);
			        	
			        	//store the tooltip info that was returned
			        	$plottedQuery.data('tooltips', response.data.tooltips);
			        	
			        	//store the method that was used to get the ids (cache or query)
			        	$plottedQuery.data('method', response.data.method);
		        	}

		        	//if this query has a dynamic filter then we need to prompt for a value and resend the request
		        	function dynamicFilterDone ()
		        	{
			        	//store the record ids that were returned
			        	if (requestData.includeData)
			        	{
				        	var records = $plottedQuery.data('records');
				        	$.each(response.data.results, function (index, recordId) {
				        		records[recordId] = {
				        			savedQueryId: $plottedQuery.data('id'),
				        			contentKey: $plottedQuery.data('id') + '-' + recordId,
				        			plottedQuery: $plottedQuery,
				        			index: index,
				        			isProcessed: false,
				        			isGeocoded: false,
				        			isVisible: false,
				        			isClustered: false,
				        			isScattered: false,
				        			isRendered: false
				        		};
				        	});
				        }
				        
			        	//determine if we need to make another callout for more results
			        	if (requestData.includeData && response.data.results.length >= 10000)
			        	{
			        		//need to get more results.  send a new request with an updated offset and don't request metadata
			        		requestData.offset = response.data.newOffset;
			        		requestData.includeMetadata = false;
			        		$.getJSON(MA.resources.Query+pageSuffix+"?action=analyze_query&SavedQueryId=" + $plottedQuery.data('id') + "&UserId=" + UserId, requestData, handleResponse)
			        		.error(function () {
			        			growlError($('#growl-wrapper'), 'Error Analyzing Query', 3000);
			        			removeQuery($plottedQuery.removeClass('loading').addClass('unloading')); 
			        		});
			        		
			        		//status update
			        		$plottedQuery.find('.status').html("{!$Label.MA_Running_query}..." + requestData.offset);
			        	}
			        	else
			        	{
				        	//done.  preload each image that this query will be using
		                    imgLoaderCounts[$plottedQuery.data('componentIndex')] = 0;
		                    $.each($plottedQuery.data('imgIds'), function (index, imgId) {
		                        var img = new Image();
		                        img.queryId = $plottedQuery.data('componentIndex');
		                        img.imgId = imgId;
		                        img.name = MA.SitePrefix+'/servlet/servlet.FileDownload?file='+imgId;
		                        img.src = MA.SitePrefix+'/servlet/servlet.FileDownload?file='+imgId;
		                        img.onload = imgLoaded;
		                        img.onerror = imgError;
		                        img.onabort = imgError;
		                        
		                        imgLoaderCounts[$plottedQuery.data('componentIndex')] = imgLoaderCounts[$plottedQuery.data('componentIndex')] + 1;
		                    });
		                    
		                    //set an interval to determine when all of the images have loaded so we can continue processing
			                imgLoaderIntervals[$plottedQuery.data('componentIndex')] = setInterval(
			                    function () {
			                        if ((imgLoaderCounts[$plottedQuery.data('componentIndex')] || 0) == 0) {
			                            clearInterval(imgLoaderIntervals[$plottedQuery.data('componentIndex')]);
			                            try { callback(true, records); } catch (err) { }
			                        }
			                    }, 400
			                );
			            }
			        }
			        if (response.data.status == 'PROMPT_DYNAMIC') 
		        	{
		        		//launch the dialog and init the user autocomplete
		        		LaunchPopupWindow($($('#DynamicFilterPopupWrapper').html()).attr('id', 'DynamicFilterPopup'), 300);
		        		$('#DynamicFilterPopup-FieldLabel').text(response.data.DynamicFilter.Label);
		        		$plottedQuery.data('DynamicFilter', { fieldLabel: response.data.DynamicFilter.Label });
		        		var $lookup = $('#DynamicFilterPopup-FieldValue');
		        		$lookup.autocomplete({
	                        focus: function (event, ui) {
	                            $lookup.val(ui.item.label);
	                            return false;
	                        },
	                        select: function (event, ui) {
	                            $lookup.val(ui.item.label).data('selectedItem', ui.item);
	                            event.stopPropagation();
	                            return false;
	                        },
	                        search: function () {
	                            $lookup.addClass('searching');
	                        },
	                        source: function(request, response) {
	                            $.ajax({
	                                url: MA.resources.Tooltip+'?action=get_lookup_options',
	                                type: 'POST',
	                                dataType: 'JSON',
	                                data: {
	                                    baseObject: 'Account',
	                                    fieldName: 'OwnerId',
	                                    term: request.term
	                                },
	                                success: function (successResponse)
	                                {
	                                    if (!successResponse.success)
	                                    {
	                                        response([]);
	                                        return;
	                                    }
	                                    
	                                    response(successResponse.lookupOptions);
	                                },
	                                error: function () 
	                                {
	                                    response([]);
	                                },
	                                complete: function ()
	                                {
	                                    $lookup.removeClass('searching');
	                                }
	                            });
	                        }
	                    });

						//default the lookup value to the current user
						$lookup.val(MA.CurrentUser.Name).data('selectedItem', { label: MA.CurrentUser.Name, value: MA.CurrentUser.Id }).select();

						//handle clicking continue
						$('#DynamicFilterPopup-Continue').click(function ()
						{
							//continue analyzing query
							requestData.includeMetadata = false;
							requestData.Dynamic = JSON.stringify([$lookup.data('selectedItem').value]);
							$.getJSON(MA.resources.Query+pageSuffix+"?action=analyze_query&UserId=" + UserId, requestData, function handleResponse (dynamicResponse) {
						        if (response.success) {
						        	$.extend(response, dynamicResponse);
						        	dynamicFilterDone();
						        }
						    });

						    //hide the popup
						    $plottedQuery.data('DynamicFilter').valueLabel = $lookup.data('selectedItem').label;
							ClosePopupWindow();
							$('#DynamicFilterPopup').remove();
				    	});

				    	//handle clicking cancel
				    	$('#DynamicFilterPopup-Cancel').click(function () {
				    		ClosePopupWindow();
				    		$('#DynamicFilterPopup').remove();
				    		removeQuery($plottedQuery);
				    	});
		        	}
		        	else {
		        		dynamicFilterDone();
		        	}
		        }
		        else
		        {
		        	$plottedQuery.removeClass('loading').addClass('error').find('.status').text(response.message); 
		        }
		    })
		    .error(function(jqXHR, textStatus, errorThrown) {
		    	$plottedQuery.removeClass('loading').addClass('error').find('.status').text('Unknown Error');
		    });
		}
		
		function refreshQuery($plottedQuery, refreshTimeoutValue)
		{
			//console.log('qid:',$plottedQuery.attr('qid'));

			if (!$.contains(document.documentElement, $plottedQuery[0]) || $plottedQuery.is('.error'))
			{
				//the query has an error or has been removed.  just do nothing
			}
			else if ($plottedQuery.is('.loading, .unloading'))
			{
				//the query is already loading.  just reset the timeout to try again later
				setTimeout(function () {
					refreshQuery($plottedQuery, refreshTimeoutValue);
				}, refreshTimeoutValue);
			}
			else
			{
				//it's time to refresh the query.  start by marking it as loading
				$plottedQuery.addClass('loading');
				$plottedQuery.find('.queryIcon').hide();
                $plottedQuery.find('.loading-icon').show();
				
				//keep track of which modes need to be rendered
				var modesToRender = [];
				$plottedQuery.find('.renderButtons-button.on').each(function () {
					modesToRender.push($(this).attr('data-renderAs'));
				});
				
				//unrender everything
				unrenderQuery($plottedQuery, 'Scatter', function () {
					unrenderQuery($plottedQuery, 'Heatmap', function () {
						unrenderQuery($plottedQuery, 'Cluster', function () {
							unrenderQuery($plottedQuery, 'Markers', function () {
							
								//clean up
								$('.plottinginfo-wrapper .icon').empty();
								try { $plottedQuery.data('distanceLimitCircle').setMap(null); } catch (err) { }

								//re-apply the qid from the attr
								var qid = $plottedQuery.attr('qid');
								$plottedQuery.data('qid', qid);
						
								//replot query
								PlotQuery({ savedQueryId: $plottedQuery.data('id'), plottedQuery: $plottedQuery }, modesToRender, $plottedQuery.data('visibleAreaOnly'));
								UpdateAddToCampaignButton();
							
							});
						});
					});
				});
				
				//I'd like to have an advanced refresh framework, but currently we're just removing and replotting
				/*
				//analyze the query
				analyzeQuery({
					plottedQuery: $plottedQuery,
					includeMetadata: false,
					destructive: false,
					callback: function (analyzeResponse) {
						MALog(success, records);
					
						//
					}
				});
				*/
			}
		}
		
		function processBatch($plottedQuery, recordBatch)
		{
			//start building a data object to send with the request
			var requestData = {
				records: JSON.stringify(recordBatch),
				tooltips: JSON.stringify(
					$.map($plottedQuery.data('tooltips'), function (tooltip, index) { 
						return { 
							FieldName: tooltip.FieldName, 
							RefFieldName: tooltip.RefFieldName 
						}; 
					})
				),
				supportsActivities: $plottedQuery.data('supportsActivities'),
				supportsCurrencies: $plottedQuery.data('supportsActivities')
			};
			
			//if this is a record query, we need to send query metadata
			if ($plottedQuery.data('savedQueryId')) 
			{
				requestData.savedQueryId = $plottedQuery.data('savedQueryId');
			}
			else 
			{
				$.extend(requestData, {
					baseObjectId		: $plottedQuery.data('baseObjectId'),
					recordIds			: $plottedQuery.data('recordIds').join(','),
					markerColor			: $plottedQuery.data('markerColor'),
					tooltipFieldsString	: $plottedQuery.data('tooltipFields').join(',')
				});
			}
			
			var records = $plottedQuery.data('records');
			var recordsToGeocode = $plottedQuery.data('recordsToGeocode');
			$.getJSON(MA.resources.Query+pageSuffix+"?action=process_batch&UserId=" + UserId, requestData, function (response) {
		        if (response.success)
		        {
		        	var latField = $plottedQuery.data('coordinateFields').Latitude;
		        	var longField = $plottedQuery.data('coordinateFields').Longitude;
		        	var verifiedLatField = $plottedQuery.data('coordinateFields').VerifiedLatitude;
		        	var verifiedLongField = $plottedQuery.data('coordinateFields').VerifiedLongitude;
		        	var addressFields = $plottedQuery.data('addressFields');
		        	
		        	//loop through the response records and extend them with the received data
		        	$.each(response.data.records, function (index, record) {
		        	
		        		//extend the record
		        		$.extend(records[record.Id], {
		        			isProcessed: true,
		        			isGeocoded: false,
		        			isBadAddress: false,
		        			record: record,
		        			latitude: extractValue(record, latField),
		        			longitude: extractValue(record, longField),
		        			verifiedLatitude: extractValue(record, verifiedLatField),
		        			verifiedLongitude: extractValue(record, verifiedLongField),
		        			markerIconText: $plottedQuery.data('markerMetadata').ColorAssignmentType == 'Static' ? '' : 'L',
		        			markerAddress: extractValue(record, addressFields.Street) + "," + extractValue(record, addressFields.City) + " " + extractValue(record, addressFields.State) + "," + extractValue(record, addressFields.Zip) + (extractValue(record, addressFields.Country) == '' ? '' : ','+extractValue(record, addressFields.Country)),
		        			formattedMarkerAddress: extractValue(record, addressFields.Street).replace(/\n\r?/g, '<br />') + "<br />" + extractValue(record, addressFields.City) + " " + extractValue(record, addressFields.State) + "," + extractValue(record, addressFields.Zip) + (extractValue(record, addressFields.Country) == '' ? '' : '<br />'+extractValue(record, addressFields.Country))
		        		});
		        		records[record.Id].markerLatitude = MA.Util.ifBlank(records[record.Id].verifiedLatitude, records[record.Id].latitude);
		        		records[record.Id].markerLongitude = MA.Util.ifBlank(records[record.Id].verifiedLongitude, records[record.Id].longitude);

		        		//determine if this record is already geocoded (make sure that the lat/long is valid).  if it's not, add it to the list to be geocoded
		        		var markerLat = parseFloat(records[record.Id].markerLatitude);
		        		var markerLong = parseFloat(records[record.Id].markerLongitude);
		        		if (!isNaN(markerLat) && !isNaN(markerLong) && markerLat >= -90 && markerLat <= 90 && markerLong >= -180 && markerLong <= 180) {
		        			records[record.Id].isGeocoded = true;
		        			records[record.Id].latLng = new google.maps.LatLng(markerLat, markerLong);
		        		}
		        		else {
		        			recordsToGeocode.push(records[record.Id]);
		        		}
		        	});
		        	
		        	//some records may not be returned due to activity filtering.  remove those records
		        	$.each(recordBatch, function (index, recordId) {
		        		if (!records[recordId].isProcessed) {
		        			delete records[recordId];
		        		}
		        	});
		        }
		        else
		        {
		        }
	    	})
		    .error(function(jqXHR, textStatus, errorThrown) {
		    });
		}
		
		function geocodeMultiple(objectsToGeocode, callback)
		{
			//build fake records so we can reuse geocodeMultipleRecords
			$.each(objectsToGeocode, function (index, obj) {
				obj.record = { Id: index };
			});

			//do geocode
			MA.Geocoding.geocodeMultipleRecords({ records: objectsToGeocode, skipSave: true }, function (response) {
				if (response.success) {
					try { callback(response.numSuccess, response.numFail); } catch (err) { }
				}
				else {
					$.each(objectsToGeocode, function (index, obj) {
			    		obj.isGeocoded = obj.isBadAddress = true;
			    	});
		    		try { callback(0, objectsToGeocode.length); } catch (err) { }
				}
			});
		}
		function geocodeMultipleRecords(recordsToGeocode, baseObjectId, callback)
		{
			MA.Geocoding.geocodeMultipleRecords({ records: recordsToGeocode, baseObjectId: baseObjectId }, function (response) {
				if (response.success) {
					try { callback(response.numSuccess, response.numFail); } catch (err) { MALog(err); }
				}
				else {
					MALog(response);
					
					//mark all as fail
					$.each(recordsToGeocode, function (index, record) {
			    		record.isGeocoded = record.isBadAddress = true;
			    	});
			    	
			    	//callback
			    	try { callback(0, recordsToGeocode.length); } catch (err) { }
				}
			});
		}
		
		function updateMissingAddressContent ($plottedQuery)
		{
			//add a missing addresses section for this query if we need one
    		if ($('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"]').length == 0)
    		{
    			//add a missing addresses section for this query
    			$('#MissingAddressesContent').append(
	    			$('.missingaddresses.template').clone().find('table').html('').closest('.missingaddresses').removeClass('template').wrap('<div/>').parent().html()
	    			.replace(/::SavedQueryId::/g, $plottedQuery.data('id'))
	    			.replace(/::SavedQueryName::/g, $plottedQuery.data('savedQueryName'))
	    		);
    		}
    		
    		//remove any missing addresses for this query
    		$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] table .missingaddress').remove();
    		
    		//loop through the records that are marked as bad addresses
    		var badAddressCount = 0;
    		var tooManyAddresses = false;
    		$.each($plottedQuery.data('records'), function (index, record) {
    			if (record.isBadAddress) {
    			
    				//limit the number of bad addresses to 1000
		    		badAddressCount++;
		    		if (badAddressCount >= 1000){
		    			tooManyAddresses = true;
		    			return false;
		    		}
    			
		    		//create a missing address for this record
		    		var $newMissingAddress = $(
		    				$('.missingaddresses.template .missingaddress').clone().wrap('<div/>').parent().html()
			    			.replace(/::RecordId::/g, record.record.Id)
			    			.replace(/::Tooltip1::/g, extractTooltipValue($plottedQuery.data('tooltips')[0], record))
			    			.replace(/::MarkerAddress::/g, record.markerAddress)
			    	);
			    	
			    	//add export data.  this data will be sent during an export request
			    	var addressFields = $plottedQuery.data('addressFields');
			    	$newMissingAddress.data('exportData', {
						recordId		: record.record.Id,
						objectType		: $plottedQuery.data('baseObjectLabel'),
						savedQueryName	: $plottedQuery.data('savedQueryName'),
						tooltip1Label	: $plottedQuery.data('tooltips')[0] ? $plottedQuery.data('tooltips')[0].FieldLabel : '',
						tooltip1Value	: extractTooltipValue($plottedQuery.data('tooltips')[0], record),
						street			: extractValue(record.record, addressFields.Street),
						city			: extractValue(record.record, addressFields.City),
						state			: extractValue(record.record, addressFields.State),
						zip				: extractValue(record.record, addressFields.Zip),
						country			: extractValue(record.record, addressFields.Country)
					});
					
			    	//append the missing address to the list for this query
		    		$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] table').append($newMissingAddress);
		    	}
    		});
    		
    		//update the missing address count
    		$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] .count').text(
    			'('+$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] .missingaddress').length+(tooManyAddresses ? '+' : '')+')'
    		);
		}
		function MissingAddress_DropPin()
		{
			var $missingAddress = $(this);
		
			//prepare a status message
			var $statusMessage = $('<div>Click the map to drop a pin or <span>cancel</span></div>');
			$statusMessage.find('span').css({ color: 'blue', cursor: 'pointer' }).click(function () {
				MA.off('nextclick');
			});
		
			//attach a handler to the next map click
			MA.on('nextclick', function (e, type) {

				//find the plotted query for this record
				var savedQueryId = $missingAddress.closest('.missingaddresses-content').attr('id').replace('_MissingAddresses_Content', '');
				var recordId = $missingAddress.attr('data-id');
				$('.PlottedRowUnit').each(function (index, $plottedQuery) {
					if ($(this).data('id') == savedQueryId) {
					
						//update the record
						var record = $(this).data('records')[recordId];
						$.extend(record, {
							isBadAddress: false,
							isGeocoded: true,
							latitude: e.latLng.lat(),
							longitude: e.latLng.lng(),
							markerLatitude: e.latLng.lat(),
							markerLongitude: e.latLng.lng(),
							latLng: e.latLng
						});
						
						//create and plot a marker for this record
						var $plottedQuery = record.plottedQuery;
		            	record.marker = CreateMarkerFromRecord(record);
		            	record.clusterMarker = CreateMarkerFromRecord(record);
		            	if ($plottedQuery.find('.renderButtons-button.markers').is('.on') && record.marker) {
		            		record.isVisible = record.isRendered = true;
		            		record.marker.setMap(MA.map);
		            		MA.Map.spiderfier.addMarker(record.marker);
                        }
                        if ($plottedQuery.find('.renderButtons-button.cluster').is('.on') && record.clusterMarker) {
                        	record.isClustered = true;
	                        $plottedQuery.data('clusterGroup').addMarker(record.clusterMarker);
	                        MA.Map.spiderfier.addMarker(record.clusterMarker);
                        }
                        if ($plottedQuery.find('.renderButtons-button.scatter').is('.on')) {
                        	record.isScattered = true;
                        	record.scatterMarker.setMap(MA.map);
                        }
					
						//update content
						$plottedQuery.data('numMarkers', ($plottedQuery.data('numMarkers') || 0) + 1);
						$plottedQuery.data('numFailedGeocodes', ($plottedQuery.data('numFailedGeocodes') || 1) - 1);
						updateMissingAddressContent($plottedQuery);
						updateQueryInfo($plottedQuery);
						MA.off('nextclick');
						
						//send requests to update the coordinates in the database
						$.ajax({
	           				url: MA.resources.Tooltip+'?action=save_tooltip',
					        type: 'POST',
					        dataType: 'JSON',
					        data: {
					        	recordId: recordId,
					        	fieldName: $plottedQuery.data('coordinateFields').Latitude,
					        	newValue: e.latLng.lat()
					        },
					        success: function (response)
					        {
					        }
					    });
					    $.ajax({
	           				url: MA.resources.Tooltip+'?action=save_tooltip',
					        type: 'POST',
					        dataType: 'JSON',
					        data: {
					        	recordId: recordId,
					        	fieldName: $plottedQuery.data('coordinateFields').Longitude,
					        	newValue: e.latLng.lng()
					        },
					        success: function (response)
					        {
					        }
					    });
					}
				});
				
			}, { message: $statusMessage });
			
			//close popup
			ClosePopupWindow();
		}
		
		function renderQuery($plottedQuery, renderAs, callback)
		{
			//show loading icon
			$plottedQuery.find('.queryIcon').hide();
    		$plottedQuery.find('.loading-icon').show();
			var affectedRecordCount = 0;
			switch (renderAs)
			{
				case 'Markers':
				        
			        //determine whether or not we need to create an ordered polyline for this query
			        var createPolyline = false;
			        try {
			        	if ($plottedQuery.data('markerMetadata').ColorAssignmentType == 'Dynamic-Order' && JSON.parse($plottedQuery.data('markerMetadata').ColorAssignment).drawLine) {
			        		createPolyline = true;
			        	}
			        }
			        catch (err) { 
			        	MALog(err);
			        }
				
					//collect data about the records that need to be processed and rendered
					var markerRendererBatchSize = 100;
					var markerRendererTimeout = 50;
					var markerProcessingBatchSize = MA.Map.hitTestShapeMgr.hasShapes() 
						? $.browser.webkit
							? 500
							: 20 
						: 1000;
					var markerProcessingTimeout = 1;
					var markersToRender = [];
					var orderedPolylineRecords = [];
					var recordsToProcess = [];
					$.each($plottedQuery.data('records'), function (index, record) {
						recordsToProcess.push(record);
					});
					
					//loop through the records in batches to determine whether or not they should be visible
					var invertProximity = $('#InvertProximityCheckbox').is(':checked');
					var queryProximityEnabled = ($plottedQuery.data('proximityOptions') && $plottedQuery.data('proximityOptions').enabled);
					var queryProximityHideMarkers = queryProximityEnabled && $plottedQuery.data('proximityOptions').hideMarkers;
					setTimeout(function doBatch() {
					
						if (recordsToProcess.length > 0)
						{
							//status update
							$plottedQuery.find('.status').text('Processing...' + recordsToProcess.length + ' remaining');
							
							var recordsProcessed = 0;
							while (recordsProcessed < markerProcessingBatchSize && recordsToProcess.length > 0)
							{
								recordsProcessed++;
								
								var record = recordsToProcess.shift();
								if (record.marker && (!record.legendRow || record.legendRow.find('.legend-checkbox').is(':checked'))) {
			    					if (MA.Map.hitTestShapeMgr.hasShapes())
			    					{
			    						//loop through all prox objects to see if this marker falls inside or outside
			    						var isInsideProxObject = MA.Map.hitTestShapeMgr.containsLatLng(record.marker.getPosition());
			    						
			    						//determine if we should continue based on whether or not prox visibility has been inverted or this query has prox enabled
			    						if (((invertProximity && isInsideProxObject) || (!invertProximity && !isInsideProxObject)) && !queryProximityEnabled)
			    						{
			    							//we should not plot this marker so continue to the next one
			    							continue;
			    						}
			    					}

			    					//if we made it this far, then we should render this marker (still check proximity options to ensure markers aren't hidden)
			    					markersToRender.push(record.marker);
			    					if (!queryProximityHideMarkers) {
			    						record.isVisible = true;
					                	record.marker.setMap(MA.map);
					                	MA.Map.spiderfier.addMarker(record.marker);
					                }
				                	
				                	//update the ordered polyline if needed
				                	if (createPolyline) {
				                	
				                		//find the proper position to add this record according to the indices
				                		var recordAdded = false;
				                		$.each(orderedPolylineRecords, function (index, polylineRecord) {
				                			if (polylineRecord.index > record.index) {
				                				orderedPolylineRecords.splice(index, 0, record);
				                				recordAdded = true;
				                				return false;
				                			}
				                		});
				                		
				                		//add the record at the end if we didn't find a place for it
				                		if (!recordAdded) {
				                			orderedPolylineRecords.push(record);
				                		}
				                	}
			    				}
			    			}
				    		
			    			//set a timeout to process the next batch
							setTimeout(doBatch, markerProcessingTimeout);
						}
						else
						{
							//check proximity options before rendering
			    			var proximityOptions = ($plottedQuery.data('proximityOptions') || {});
			    			var proximityObjects = $plottedQuery.data('proximityObjects');
			    			if (proximityOptions.enabled)
			    			{
			    				//this query cannot be clustered, just render the markers/circles
			    				$.each(markersToRender, function (index, marker) {
									
									//render circle
									try 
									{
										if(proximityOptions.selectType == 'circle')
										{
										    /*
											var newCircle = new google.maps.Circle({
										       	map: MA.map,
										       	center: marker.getPosition(),
										       	radius: proximityOptions.radius * unitFactors[proximityOptions.measurementType]['METERS'],
										       	layerType: 'prox',
												strokeColor: '#882233',
												strokeWeight: 3,
												strokeOpacity: 1,
					                        	fillColor: '#223388',
					                        	fillOpacity: 0.7,
					                        	maData: { marker: marker }
											});
											*/
											
											var newCircle = new google.maps.Circle({
										       	map: MA.map,
										       	center: marker.getPosition(),
										       	radius: proximityOptions.radius * unitFactors[proximityOptions.measurementType]['METERS'],
										       	layerType: 'prox',
												strokeColor: proximityOptions.border,
												strokeWeight: 3,
												strokeOpacity: 1,
					                        	fillColor: proximityOptions.fill,
					                        	fillOpacity: proximityOptions.opacity,
					                        	maData: { marker: marker }
											});
											
											//console.log(newCircle);
											
											
											proximityObjects.push(newCircle);

											//keep track of this circle so it can be toggled with the marker
											marker.maData = $.extend(marker.maData || {}, { proximityCircle: newCircle });
											
											//handle clicking on the circle
											google.maps.event.addListener(newCircle, 'click', function (e) {
						                        proximityLayer_Click({ position: e.latLng, type: 'circle', shape: newCircle });
						                    });
						                    google.maps.event.addListener(newCircle, 'rightclick', function (e) {
						                        Shape_Context.call(this, e);
						                    });
										}
									}
									catch (err) { }
			    				});
			    				
			    				//update the query info
                  $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
                  $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').addClass('active');
                  updateQueryInfo($plottedQuery);
			    				
			    				//update visibility for other queries
			    				ChangeVisibilityWhenCircleIsAdded();
			    			}
			    			else if (createPolyline)
			    			{
		    					//build an array of coordinates for the polyline
		    					var orderedPolylineCoordinates = [];
		    					$.each(orderedPolylineRecords, function (index, orderedPolylineRecord) {
		    						orderedPolylineCoordinates.push(orderedPolylineRecord.marker.getPosition());
		    					});
		    				
		    					//build the polyline and add it to the map
		    					var orderedPolyline = new google.maps.Polyline({
		    						map: MA.map,
	                                path: orderedPolylineCoordinates, 
	                                strokeColor: "#F95",
	                                strokeWeight: 3
	                            });
	                            
	                            //store the polyline with the plotted query so it can be removed later
	                            $plottedQuery.data({
	                            	orderedPolyline: orderedPolyline,
	                            	orderedPolylineCoordinates: orderedPolylineCoordinates
	                            });
	                            
	                            //update the query info
                              $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
                              $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').addClass('active');
	                            updateQueryInfo($plottedQuery);
			    			}
			    			else
			    			{
			    				//nothing else to do, just update the query info
			    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
			    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').addClass('active');
			    				updateQueryInfo($plottedQuery);
			    			}
			    			
			    			//done rendering, so hide markers based on unchecked values in the legend (if we have any)
		    				$plottedQuery.find('.legend-checkbox').not(':checked').change();
		    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
		    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').addClass('active');
			    			
							//done, so fire the callback
							MA.Analytics.track('queryrun', { params: { plotmode: renderAs, queryid: $plottedQuery.data('savedQueryId') || '', records: markersToRender.length } });
						    try { callback(); } catch (err) { }
					    	return;
						}
					
					}, markerProcessingTimeout);

				break;	
				case 'Heatmap':
					
					//build a list of heatmap data points and add it
					var heatMapDataPoints = [];
					
					var LowestHeatMapWeightedValue = 9999999999;
					var HighestHeatMapWeightedValue = -9999999999;
					
					//console.log($plottedQuery.data());
					
					//check to see if we have a weighted value
					if ($plottedQuery.data('advancedOptions').all.heatmapWeightedValue && $plottedQuery.data('advancedOptions').all.heatmapWeightedValue != 'None')
					{
					    var heatmapWeightedValue = $plottedQuery.data('advancedOptions').all.heatmapWeightedValue;
					    
					   
					    
					    $.each($plottedQuery.data('records'), function (index, record) {
					        
					        if (record.record[heatmapWeightedValue])
					        {
					            if (MA.Util.testLatLng(record.markerLatitude, record.markerLongitude)) 
        	    				{
        	    				    //var OldValue = parseFloat(record.record[heatmapWeightedValue]);
        	    				    
        	    				    var value = parseFloat(record.record[heatmapWeightedValue]);
        	    				    
        	    				    if (value > HighestHeatMapWeightedValue)
        	    				    {
        	    				        HighestHeatMapWeightedValue = value;
        	    				    }
        	    				    
        	    				    if (value < LowestHeatMapWeightedValue)
        	    				    {
        	    				        LowestHeatMapWeightedValue = value;
        	    				    }
        	    				    
        	    					heatMapDataPoints.push({
        	    					    'location': new google.maps.LatLng(record.markerLatitude, record.markerLongitude),
        	    					    'weight' :  parseFloat(record.record[heatmapWeightedValue])
        	    					});
        	    					

        	    				}
					        }
    	    			});
    	    			
    	    			
    	    			
					}
					else
					{
					    //Doesn't look like we have a weighted value so let's add all records
					    $.each($plottedQuery.data('records'), function (index, record) {
    	    				if (MA.Util.testLatLng(record.markerLatitude, record.markerLongitude)) {
    	    					heatMapDataPoints.push(new google.maps.LatLng(record.markerLatitude, record.markerLongitude));
    	    				}
    	    			});
					}
					
					
					//console.log(heatMapDataPoints);
					

	                //remove the existing heat map if there is one
	                if ($plottedQuery.data('heatmapLayer')) {
	                	$plottedQuery.data('heatmapLayer').setMap(null);
	                	$plottedQuery.data('heatmapLayer', null);
	                }
		                
	                //create a new heatmap and add it to the map, let's assume if we have a heatmapWeightedValue; that all the settings are filled out
	                if ($plottedQuery.data('advancedOptions').all.heatmapWeightedValue)
	                {
	                    //'rgba(0,0,0,0)'
	                    
	                    
	                    var heatmapOptions = $plottedQuery.data('advancedOptions').all;
	                    var heatmapGradient = JSON.parse(heatmapOptions.heatmapGradient);
	                    heatmapGradient.splice(0,0,'rgba(0,0,0,0)');
	                    
	                    var HeatMapLayervar = new google.maps.visualization.HeatmapLayer({
    						map: MA.map,
    						data: heatMapDataPoints,
    						dissipating: (heatmapOptions.heatmapDissipating == 'true') ? true : false,
    						gradient: heatmapGradient,
    						maxIntensity: parseFloat(heatmapOptions.heatmapMaxIntensity),
    						radius: parseFloat(heatmapOptions.heatmapRadius),
    						opacity: parseFloat(heatmapOptions.heatmapOpacity),
    	                    plottedQuery: $plottedQuery,
    	                });
    	                
	                    //fill out the options in the plotted layer
    	                $plottedQuery.find('#heatIntensity').val(parseFloat(heatmapOptions.heatmapMaxIntensity));
    	                $plottedQuery.find('#heatRadius').val(parseFloat(heatmapOptions.heatmapRadius));
    	                if(heatmapOptions.heatmapDissipating == 'true') {
    	                	$plottedQuery.find('#heatDissipate').attr('checked','checked');
    	                }
    	                else {
    	                	$plottedQuery.find('#heatDissipate').removeAttr('checked');
    	                }
    	                $plottedQuery.find('.heatmapOpacity').val(heatmapOptions.heatmapOpacity);
    	                $plottedQuery.find('.heatmap-opitons').show();

    	                //console.log(HeatMapLayervar);
	                    
	                    $plottedQuery.data('heatmapLayer', HeatMapLayervar);
	                    
	                    $plottedQuery.data('lowestHeatMapWeightedValue', LowestHeatMapWeightedValue);
	                    $plottedQuery.data('highestHeatMapWeightedValue', HighestHeatMapWeightedValue);
	                    
	                }
	                else
	                {
	                    $plottedQuery.data('heatmapLayer', new google.maps.visualization.HeatmapLayer({
    						map: MA.map,
    						data: heatMapDataPoints,
    						dissipating: true,
    	                    radius: 15,
    	                    opacity: 0.8,
    	                    maxIntensity: 5,
    	                    gradient: ['rgba(0,0,0,0)', 'rgb(0,0,255)', 'rgb(0,255,255)', 'rgb(0,255,0)', 'yellow', 'rgb(255,0,0)'],
    	                    plottedQuery: $plottedQuery,
    	                }));

    	                $plottedQuery.find('.heatmap-opitons').show();
	                }
	                
	                
	                
	                
	                
		            //update the plotted query
	                $plottedQuery.data('numHeatmapDataPoints', heatMapDataPoints.length);
	                $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
	                $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').addClass('active');
	                //$plottedQuery.find('.heatmap-legend').show();
	                
	                //update query info
				    updateQueryInfo($plottedQuery);
	                
	                //done so fire callback
	                MA.Analytics.track('queryrun', { params: { plotmode: renderAs, queryid: $plottedQuery.data('savedQueryId') || '', records: heatMapDataPoints.length } });
	                try { callback(); } catch (err) { }
					
				break;	
				case 'Cluster':
				    
					//collect data about the records that need to be processed and rendered
					var markerRendererBatchSize = 100;
					var markerRendererTimeout = 50;
					var markerProcessingBatchSize = 1000;
					var markerProcessingTimeout = 1;
					var markersToRender = [];
					var orderedPolylineRecords = [];
					var recordsToProcess = [];
					$.each($plottedQuery.data('records'), function (index, record) {
						recordsToProcess.push(record);
					});
					
					//loop through the records in batches to determine whether or not they should be visible
					var invertProximity = $('#InvertProximityCheckbox').is(':checked');
					setTimeout(function doBatch() {
					
						if (recordsToProcess.length > 0)
						{
							//status update
							$plottedQuery.find('.status').text('Processing...' + recordsToProcess.length + ' remaining');
							
							var recordsProcessed = 0;
							while (recordsProcessed < markerProcessingBatchSize && recordsToProcess.length > 0)
							{
								recordsProcessed++;
							
								var record = recordsToProcess.shift();
								if (record.clusterMarker && (!record.legendRow || record.legendRow.find('.legend-checkbox').is(':checked'))) {
			    					if (MA.Map.hitTestShapeMgr.hasShapes())
			    					{
			    						//loop through all prox objects to see if this marker falls inside or outside
			    						var isInsideProxObject = MA.Map.hitTestShapeMgr.containsLatLng(record.marker.getPosition());
			    						
			    						//determine if we should continue based on whether or not prox visibility has been inverted or this query has prox enabled
			    						if (((invertProximity && isInsideProxObject) || (!invertProximity && !isInsideProxObject)) && !queryProximityEnabled)
			    						{
			    							//we should not plot this marker so continue to the next one
			    							continue;
			    						}
			    					}
			    					
			    					//if we made it this far, then we should render this marker
		    						record.isClustered = true;
				                	markersToRender.push(record.clusterMarker);
				                	MA.Map.spiderfier.addMarker(record.clusterMarker);
			    				}
			    			}
			    		
		    				//set a timeout to process the next batch
							setTimeout(doBatch, markerProcessingTimeout);
						}
						else
						{
							//status update
							$plottedQuery.find('.status').text('Rendering Clusters');
							
							//create a cluster group and add it to the map
							var clusterer;
							clusterer = new MarkerClusterer(MA.map, markersToRender.slice(0, MA.limits.maxClusterSize), { 
								zoomOnClick: false,
						    	savedQueryName: $plottedQuery.data('savedQueryName')
						    });
						    
						    //handle clicking a cluster
						    google.maps.event.addListener(clusterer, 'click', cluster_Click);
						    google.maps.event.addListener(clusterer, 'rightclick', cluster_context);
						    
						    //store the cluster group so it can be removed later
						    $plottedQuery.data('clusterGroup', clusterer);
						    $plottedQuery.data('numClusterDataPoints', clusterer.getTotalMarkers());
						    $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
						    $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').addClass('active');
						    
						    //update query info
						    updateQueryInfo($plottedQuery);
						    
						    //done so fire callback
						    MA.Analytics.track('queryrun', { params: { plotmode: renderAs, queryid: $plottedQuery.data('savedQueryId') || '', records: markersToRender.length } });
						    try { callback(); } catch (err) { }
						}
					
					}, markerProcessingTimeout);
					
				break;
				case 'Scatter':
				
					//collect data about the records that need to be processed and rendered
					var markerRendererBatchSize = 100;
					var markerRendererTimeout = 50;
					var markerProcessingBatchSize = MA.Map.hitTestShapeMgr.hasShapes() 
						? $.browser.webkit
							? 500
							: 20 
						: 1000
					;
					var markerProcessingTimeout = 1;
					var markersToRender = [];
					var recordsToProcess = [];
					$.each($plottedQuery.data('records'), function (index, record) {
						recordsToProcess.push(record);
					});
					
					//loop through the records in batches to determine whether or not they should be visible
					var invertProximity = $('#InvertProximityCheckbox').is(':checked');
					var queryProximityEnabled = ($plottedQuery.data('proximityOptions') && $plottedQuery.data('proximityOptions').enabled);
					setTimeout(function doBatch() {
					
						if (recordsToProcess.length > 0)
						{
							//status update
							$plottedQuery.find('.status').text('Processing...' + recordsToProcess.length + ' remaining');
							
							var recordsProcessed = 0;
							while (recordsProcessed < markerProcessingBatchSize && recordsToProcess.length > 0)
							{
								recordsProcessed++;
								
								var record = recordsToProcess.shift();
								if (record.marker && (!record.legendRow || record.legendRow.find('.legend-checkbox').is(':checked'))) {
			    					if (MA.Map.hitTestShapeMgr.hasShapes())
			    					{
			    						//loop through all prox objects to see if this marker falls inside or outside
			    						var isInsideProxObject = MA.Map.hitTestShapeMgr.containsLatLng(record.marker.getPosition());
			    						
			    						//determine if we should continue based on whether or not prox visibility has been inverted or this query has prox enabled
			    						if (((invertProximity && isInsideProxObject) || (!invertProximity && !isInsideProxObject)) && !queryProximityEnabled)
			    						{
			    							//we should not plot this marker so continue to the next one
			    							continue;
			    						}
			    					}
			    					
			    					//if we made it this far, then we should render this marker
		    						record.isScattered = true;
				                	markersToRender.push(record.scatterMarker);
			    				}
			    			}
				    		
			    			//set a timeout to process the next batch
							setTimeout(doBatch, markerProcessingTimeout);
						}
						else
						{
							//render each marker
							$.each(markersToRender, function (i, marker) {
								marker.setMap(MA.map);
							});
			    			
			    			//done rendering, so hide markers based on unchecked values in the legend (if we have any)
			    			$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
			    			$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').addClass('active');
		    				
		    				
		    				//update query info
						    updateQueryInfo($plottedQuery);
			    			
							//done, so fire the callback
							MA.Analytics.track('queryrun', { params: { plotmode: renderAs, queryid: $plottedQuery.data('savedQueryId') || '', records: markersToRender.length } });
						    try { callback(); } catch (err) { }
					    	return;
						}
					
					}, markerProcessingTimeout);
				
				break;
				default:

					updateQueryInfo($plottedQuery);
					try { callback(); } catch (err) { }

				break;
			}
		}
		
		function unrenderQuery($plottedQuery, renderAs, callback, options)
		{
			//show loading icon
			$plottedQuery.find('.queryIcon').hide();
    		$plottedQuery.find('.loading-icon').show();

			MA.Map.InfoBubble.hide();
			switch (renderAs)
			{
				case 'Markers':
				
					var markerUnrendererBatchSize = 120;
					var markerUnrendererTimeout = 100;
					
					//remove any query based prox circles
					var proximityObjects = $plottedQuery.data('proximityObjects');
					$.each(proximityObjects || [], function (index, proxObject) {
						try {
							proxObject.setMap(null);
						}
						catch (err) {}
					});
					$plottedQuery.data('proximityObjects', []);
					
					//remove the ordered polyline if it exists
					try {
						$plottedQuery.data('orderedPolyline').setMap(null);
					}
					catch (err) { }
					
					//determine if this is a proximity query
					var queryProximityEnabled = ($plottedQuery.data('proximityOptions') && $plottedQuery.data('proximityOptions').enabled);
			        
			        //mark each record as not visible
			        var markers = [];
			        $.each(($plottedQuery.data('records') || []), function (index, record) {
		   				if (record.marker && record.isVisible) {
		   					record.isVisible = false;
		   					markers.push(record.marker);
		   					record.marker.setMap(null);
		   					MA.Map.spiderfier.removeMarker(record.marker);
		   					
		   					//try to remove any tooltips associated with this marker
		   					if (record.marker.popupHandle) {
		   						try {
		   							record.marker.popupHandle.setMap(null);
		   						}
		   						catch (err) { }
		   					}
		   				}
		   			});
		   						        
					//done, so fire the callback
    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').removeClass('on');
    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('active');

    				if($plottedQuery.attr('ignore-sudo-class') != 'true') {

    					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('sudo-active');
    				}

    				if (proximityObjects && proximityObjects.length > 0) {
    					ChangeVisibilityWhenCircleIsAdded();
    				}
    				updateQueryInfo($plottedQuery);
    				try { callback(); } catch (err) { }
			   		
					break;
				case 'Heatmap':
				
					//remove heat map if it exists
					if ($plottedQuery.data('heatmapLayer')) {
						$plottedQuery.data('heatmapLayer').setMap(null);
					}
					
					//fire the callback
					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').removeClass('on');
					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('active');

					if($plottedQuery.attr('ignore-sudo-class') != 'true') {
    					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('sudo-active');
    				}

					updateQueryInfo($plottedQuery);
					try { callback(); } catch (err) { }
					$plottedQuery.find('.heatmap-opitons').hide();
					break;
				case 'Cluster':
				
					//remove the query cluster if it exists
					if ($plottedQuery.data('clusterGroup')) {
					
						//try to remove any tooltips associated with this cluster
   						try {
   							$plottedQuery.data('clusterGroup').popupHandle.setMap(null);
   						}
   						catch (err) { }
					
						//remove the cluster
						$plottedQuery.data('clusterGroup').clearMarkers();
						$plottedQuery.removeData('clusterGroup');
					}
					
					//unrender markers from the plotted queries cluster in batches using a timeout
					var markerUnrendererBatchSize = 120;
					var markerUnrendererTimeout = 100;
					$plottedQuery.data(
						'markerUnrendererTimeout', 
						setTimeout(function doBatch() {
						
							//remove markers
							var markerCount = 0;
				   			$.each(($plottedQuery.data('records') || []), function (index, record) {
				   				if (record.clusterMarker && record.isClustered) {
				   					record.isClustered = false;
				   					MA.Map.spiderfier.removeMarker(record.clusterMarker);
				   					markerCount++;
				   				}
				   				
				   				if (markerCount > markerUnrendererBatchSize) { return false; }
				   			});
				   			
				   			//should we keep unrendering?
			    			if (markerCount == 0)
			    			{
								//fire the callback
								$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').removeClass('on');
								$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('active');

								if($plottedQuery.attr('ignore-sudo-class') != 'true') {
			    					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('sudo-active');
			    				}

								updateQueryInfo($plottedQuery);
								try { callback(); } catch (err) { }
			    			}
			    			else
			    			{
			    				//yes, so set a new timeout to process the next batch
			    				setTimeout(doBatch, markerUnrendererTimeout);
			    			}
			   			
			   			}, markerUnrendererTimeout)
			   		);

				break;
				case 'Scatter':
				
					//mark each record as not scattered
			        var markers = [];
			        $.each(($plottedQuery.data('records') || []), function (index, record) {
			        	record.isScattered = false;
			        	try { record.scatterMarker.setMap(null); } catch (err) {}
		   			});
		   			
		   			//set legend row visible markers to 0
		   			if (!$plottedQuery.find('.renderButtons-button.markers').is('.on') && !$plottedQuery.find('.renderButtons-button.cluster').is('.on')) {
		   				$plottedQuery.find('.legend-row .visiblemarkers').text('0');
		   			}
			        
					//done, so fire the callback
    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').removeClass('on');
    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('active');

    				if($plottedQuery.attr('ignore-sudo-class') != 'true') {
    					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').closest('li').removeClass('sudo-active');
    				}

    				updateQueryInfo($plottedQuery);
    				try { callback(); } catch (err) { }
				
				break;
			}
		}
		
		function updateQueryInfo($plottedQuery)
		{
		    //console.log('updateQueryInfo');
		    //console.log($plottedQuery.data());
		    
			var infoHTML = '';
			var queryData = $plottedQuery.data();
			
			//resize the query name based on the number of visible render buttons
			$plottedQuery.find('.basicinfo-name').attr('title', $plottedQuery.find('.basicinfo-name').text());
			
			//general data point info
			$plottedQuery.find('.status').html("{!$Label.MA_Data_Points}: " + $plottedQuery.data('numRecords') + ($plottedQuery.data('method') == 'cache' ? ' (from cache)' : ''));
			
			//geocode info
			if (queryData.numGeocodeRequestsNeeded > 0) {
				infoHTML += "<div>"+queryData.numGeocodeRequestsNeeded+" {!$Label.MA_geocodes_completed}.  <span class='geocode link'>"+queryData.numFailedGeocodes+" {!$Label.MA_bad_address}</span>.</div>";
			}
			
			//zero out the legends (will be updated in the loop below)
			$plottedQuery.find('.legend-row .visiblemarkers, .legend-row .totalmarkers').text('0');
			
			//calculate render info
			var visibleCount = 0;
			var clusterCount = 0;
			var scatterCount = 0;
			$.each(queryData.records || [], function (recordId, record) {
				if (record.isVisible) { visibleCount++; }
				if (record.isClustered) { clusterCount++; }
				if (record.isScattered) { scatterCount++; }
				if (record.isVisible || record.isClustered || record.isScattered) {
					if (record.legendRow) {
					    record.legendRow.find('.visiblemarkers').text((parseInt(record.legendRow.find('.visiblemarkers').text()) || 0) + 1);
				   	}
				}
				if (record.legendRow) {
					record.legendRow.find('.totalmarkers').text((parseInt(record.legendRow.find('.totalmarkers').text()) || 0) + 1);
				}
			});
			
			//marker info
			if ($plottedQuery.find('.renderButtons-button.markers').is('.on')) {
				infoHTML += "<div>"+queryData.numMarkers+" {!$Label.MA_Markers_Created}, "+visibleCount+" {!$Label.MA_Visible}.</div>";
			}
			
			//heatmap info
			if ($plottedQuery.find('.renderButtons-button.heatmap').is('.on')) {
				infoHTML += "<div>"+$plottedQuery.data('numHeatmapDataPoints')+" heatmap {!$Label.MA_Data_Points}.</div>";
				if (queryData.advancedOptions && queryData.advancedOptions.all && queryData.advancedOptions.all.heatmapWeightedValue && queryData.advancedOptions.all.heatmapWeightedValue != "" && queryData.advancedOptions.all.heatmapWeightedValue != "None")
				{
				    infoHTML += "<div>"+"Range: " + queryData.lowestHeatMapWeightedValue + " - " + queryData.highestHeatMapWeightedValue + "</div>";
				}
			}
			
			//cluster info
			if ($plottedQuery.find('.renderButtons-button.cluster').is('.on')) {
				infoHTML += "<div>"+clusterCount+" cluster {!$Label.MA_Data_Points}.</div>";
			}
			
			//scatter info
			if ($plottedQuery.find('.renderButtons-button.scatter').is('.on')) {
				infoHTML += "<div>"+scatterCount+" scatter {!$Label.MA_Data_Points}.</div>";
			}
			
			//legend info
			$.each($plottedQuery.data('tooltips') || [], function (index, tooltip) {
				if (tooltip.TooltipType == 'Color') {
					infoHTML += "<div style='color: black;margin-top: 10px;'>Legend Field: "+tooltip.FieldLabel+"</div>";
				}
			});
			
			
			if (queryData.advancedOptions && queryData.advancedOptions.all && queryData.advancedOptions.all.automaticassign)
			{
			    if (queryData.advancedOptions.all.automaticassign == 'true' && queryData.numRecords > 10000)
    			{
    			    infoHTML += "<div style='color: red;margin-top: 10px;'>Dynamic Markers are only active when there are less than 10,000 results.</div>";
    			}
			}
			

			//dynamic query info
			if ($plottedQuery.data('DynamicFilter')) {
				infoHTML += "<div>Dynamic Filter: " +$plottedQuery.data('DynamicFilter').fieldLabel+ " = " +$plottedQuery.data('DynamicFilter').valueLabel+ "</div>";
			}
			
			$plottedQuery.find('.plottinginfo-wrapper .info').html(infoHTML);

			//update drop menu depending on what is rendered
			if($plottedQuery.find('.item-selectable.active').length > 1) {
				$plottedQuery.find('#select-hide').attr('checked',true);
				$plottedQuery.find('.glyphicon-eye-close, .select-icon').hide();
				$plottedQuery.find('.plotted-visibile-icon .svg-circle-num').remove();

				//add circle icon
				var $cirIcon = $('#templates .svg-circle-num').clone().wrap('<div/>').parent().html()
						.replace(/__TEXT__/g, $plottedQuery.find('.item-selectable.active').length);
				$plottedQuery.find('.plotted-visibile-icon .multi-select').show().append($cirIcon);
			}
			else if ($plottedQuery.find('.item-selectable.active').length == 1) {
				$plottedQuery.find('#select-hide').attr('checked',true);
				$plottedQuery.find('.glyphicon-eye-close, .multi-select').hide();
				var mode = $plottedQuery.find('.item-selectable.active a').attr('data-renderas');
				$plottedQuery.find('.plotted-visibile-icon .select-icon').removeClass('Heatmap Cluster Markers Scatter');
				$plottedQuery.find('.plotted-visibile-icon .select-icon').addClass(mode).show();
			}
			else {
				$plottedQuery.find('#select-hide').removeAttr('checked');
				$plottedQuery.find('.plotted-visibile-icon .glyphicon-eye-close').show();
				$plottedQuery.find('.multi-select, .select-icon').hide();
			}
		}
		
		function removeQuery($plottedQuery, options)
		{
			//show loading icon
			$plottedQuery.find('.queryIcon').hide();
    		$plottedQuery.find('.loading-icon').show();

			//default options
			options = $.extend({
				complete: function () {}
			}, options || {});
		
			//unrender everything
			unrenderQuery($plottedQuery, 'Scatter', function () {
				unrenderQuery($plottedQuery, 'Heatmap', function () {
					unrenderQuery($plottedQuery, 'Cluster', function () {
						unrenderQuery($plottedQuery, 'Markers', function () {
							
							//remove plotted query
						    try { $plottedQuery.data('distanceLimitCircle').setMap(null); } catch (err) { }
						    $('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"]').closest('.missingaddresses').remove();
						    $plottedQuery.slideUp(300, function () 
						    {
							    $plottedQuery.remove();
							    UpdateAddToCampaignButton();
							
							    //Show water-mark
							    if($('#PlottedQueriesTable').children().length == 0) {
								    $('#PlottedQueriesWrapper .plotted-watermark').slideDown(200);
			                    }
			                
			                    //reload any popups that this may have affected
	                		    refreshPopups();
	                		    
	                		    //done
	                		    options.complete();
						    });
						});					
					});
				});
			});
		}
		
		function removeAllLayers()
		{
			//remove all of the tabs too
			MAListView.RemoveAllTabs();

			function doRemove() {
				var $layerToRemove = $('#PlottedQueriesTable .PlottedRowUnit, #PlottedQueriesTable .PlottedShapeLayer, #PlottedQueriesTable .proximity.layer').first();
				if ($layerToRemove.length != 0)
				{
					if ($layerToRemove.is('.PlottedRowUnit')) 
					{
						removeQuery($layerToRemove.addClass('unloading'), { complete: doRemove });
					}
					else 
					{
						removeProximityLayer($layerToRemove.addClass('unloading'), { complete: doRemove });
					}
				}
			}
			doRemove();
			
			//no need to batch these, so let's remove all of them
			$('#PlottedQueriesTable .RulerRowUnit').find('.btn-remove').click();
			
		}
		
		function CreateMarkerFromRecord(record, options)
		{
		    /*
		    console.log('CreateMarkerFromRecord');
		    console.log(record);
		    console.log(options);
		    */
		    
			options = $.extend({
				markerType: 'auto',
				isForCluster: false,
				isForScatter: false
			}, options);
		
			//get the value of the first tooltip (it will be used as the title for this marker)
            var tooltip1Value = 'Unknown';
            var tooltip1Metadata = record.plottedQuery.data('tooltips')[0];
            
            var advancedOptions = record.plottedQuery.data('advancedOptions');
            
            if (tooltip1Metadata)
            {
            	tooltip1Value = extractTooltipValue(tooltip1Metadata, record, true);
            }
            
            //console.log('tooltip1Value: ' + tooltip1Value);
            
            //get the color/image for this marker
            var markerMetadata = record.plottedQuery.data('markerMetadata');
            var markerColor = '#000000';
            var otherColor = '#000000';
            if (options.markerType == 'Waypoint')
            {
            	//this is just a placeholder so nothing else happens.  the options are used below to extend the created marker
            }
            else if (markerMetadata.ColorAssignmentType == 'Static')
            {
            	markerColor = markerMetadata.IconColor;
            }
            else if (markerMetadata.ColorAssignmentType == 'Dynamic, Field')
            {
            	var foundMatch = false;
            	var picklistValue = extractValue(record.record, markerMetadata.PicklistField);
            	var matchedindex;
            	
            	//fix for boolean field type being compared to strings
            	if (typeof picklistValue == 'boolean') {
            		picklistValue = picklistValue ? 'True' : 'False';
            	}
            	
            	//function to handle rounding for currency 
		        function round(num, places) {
					var multiplier = Math.pow(10, places);
					return Math.round(num * multiplier) / multiplier;
				}
            	
            	//loop over the color assignment rules looking for a match
            	$.each(markerMetadata.colorAssignmentrules, function (index, rule) {
	            	
           			//keep track of the 'other color' value for use later
           			if(rule.comparevalue == '<Other>')
           			{
           				otherColor = rule.value;
           			}
	            			
           			//check if this matches based on the operator
           			if(rule.operator == 'contains')
           			{
           				if(picklistValue.toLowerCase().indexOf(rule.comparevalue.toLowerCase())== -1)
           				{
           				}
           				else
           				{
           					markerColor = rule.value;
           					foundMatch = true;
           					matchedindex = index;
           				}
           			}
           			else if(rule.operator == 'starts')
           			{
           				if(picklistValue.toLowerCase().indexOf(rule.comparevalue.toLowerCase())== 0)
           				{
           					markerColor = rule.value;
           					foundMatch = true;
           					matchedindex = index;
           				}
           			}
           			else if(rule.operator == 'equals')
           			{
           				if(picklistValue.toLowerCase() == rule.comparevalue.toLowerCase())
       					{
       						markerColor = rule.value;
       						foundMatch = true;
       						matchedindex = index;
       					}
           			}
           			else if(rule.operator == 'includes')
           			{
           				var picklistArray = picklistValue.toLowerCase().split(';');
           				var selectionArray = rule.comparevalue.toLowerCase().split('~~');
           				if($(picklistArray).not(selectionArray).length == 0 && $(selectionArray).not(picklistArray).length == 0 && picklistValue.toLowerCase() != '')
           				{
           					markerColor = rule.value;
       						foundMatch = true;
       						matchedindex = index;
           				}
           			}
           			else if(rule.operator == 'excludes')
           			{
           				var picklistArray = picklistValue.toLowerCase().split(';');
           				var selectionArray = rule.comparevalue.toLowerCase().split('~~');
						function containsNone(portion, total)
						{ 
							for(var i = 0 , len = portion.length; i < len; i++)
							{
								if($.inArray(portion[i], total) >= 0) return false;
							}
							return true;
						}
						if(containsNone(selectionArray,picklistArray) == true && picklistValue.toLowerCase() != '')
						{
							markerColor = rule.value;
       						foundMatch = true;
       						matchedindex = index;
						}
           			}
           			else if(rule.operator == 'currency')
           			{
           				fromval = rule.comparevalue.replace(/,/g, '');
           				toval = rule.toVal.replace(/,/g, '');
           				
           				//var to store converted picklist for user currency
           				var convertedValue = picklistValue;
           				
           				//check for currency support and convert to user settings
           				if(userSettings.currency && userSettings.userCurrency) {
           					//loop over currencies and find any different
           					$.each(userSettings.currency, function (index,currency) {
			           			
			           			//convert values to user currency settings
			           			if(currency.IsoCode == record.record.CurrencyIsoCode && userSettings.userCurrency != record.record.CurrencyIsoCode)
			           			{
			           				//convert picklist value to user settings
			           				var userConverstionRate = userSettings.userConverstionRate;
			           				var conversionRate = currency.ConversionRate/userConverstionRate;
			           				convertedValue = picklistValue/conversionRate;
			           			}
			           			else if(currency.IsoCode == record.record.CurrencyIsoCode)
			           			{
			           				convertedValue = picklistValue;
			           			}
			           		});
           				}
           				
           				//check decimal length of entered values
           				var decimalLength;
           				if((fromval % 1 != 0 || toval % 1 != 0) == true)//is it a decimal?
						{
   							decimalLength = fromval.split('.').length == 2 ? fromval.split('.')[1].length : 2;
   						}
   						else
   						{
   							decimalLength = 0;
   						}
   						
   						//round picklistValue to ensure we catch all values if decimal is used
   						round(convertedValue, decimalLength);
           				
           				if(isNaN(parseInt(convertedValue)) == true)
       					{
       						markerColor = otherColor;
       					}
           				else if (convertedValue >= fromval && convertedValue <= toval)
       					{
       						markerColor = rule.value;
       						foundMatch = true;
       						matchedindex = index;
       					}
           				else if (convertedValue >= fromval && toval == '')
       					{
       						markerColor = rule.value;
       						foundMatch = true;
       						matchedindex = index;
       					}
       					else if (convertedValue <= toval && fromval == '')
       					{
       						markerColor = rule.value;
       						foundMatch = true;
       						matchedindex = index;
       					}
           			}
           			else if(rule.operator == 'date')
           			{
           				//check if either value is a date literal
           				var fromMatches = false;
           				var fromIsDateLiteral = false;
           				var toMatches = false;
           				var toIsDateLiteral = false;
	                    for (var i in MADateLiterals)
	                    {
	                        //check if the label matches and the value is not blank (blank value denotes a dynamic date literal and cannot be matched directly)
	                        if (MADateLiterals[i].label == rule.comparevalue && MADateLiterals[i].value != 'DYNAMIC')
	                        {
	                        	fromIsDateLiteral = true;
	                        	
	                            //compare
	                            if (moment(picklistValue)) {
		                            if (moment(picklistValue).isBefore(MADateLiterals[i].getMoment(), MADateLiterals[i].momentUnit)) {
		                            	return;
		                            }
		                            else {
		                            	fromMatches = true;
		                            }
		                        }
	                        }
	                        if (MADateLiterals[i].label == rule.enddate && MADateLiterals[i].value != 'DYNAMIC')
	                        {
	                        	toIsDateLiteral = true;
	                        	
	                        	//compare
	                        	if (moment(picklistValue)) {
	                        		if (moment(picklistValue).isAfter(MADateLiterals[i].getMoment(), MADateLiterals[i].momentUnit)) {
	                        			return;
		                        	}
		                        	else {
		                        		toMatches = true;
		                        	}
	                        	}
	                        }
	                    }
	                    
	                    //check if the from value is a dynamic date literal
	                    try {
	                        var stringParts = rule.comparevalue.split(' ');
	                        if (stringParts[0] == 'NEXT' || stringParts[0] == 'LAST') {
	                        	if (!isNaN(parseInt(stringParts[1])) && stringParts.length == 3 && $.inArray(stringParts[2], ['DAYS', 'QUARTERS', 'YEARS']) != -1) {
	                        		fromIsDateLiteral = true;
			                        if (stringParts[0] == 'NEXT' && !moment(picklistValue).isBefore(moment().add(stringParts[2].toLowerCase(), 1), stringParts[2].slice(0, -1).toLowerCase())) {
	                                    fromMatches = true;
			                        }
			                        else if (stringParts[0] == 'LAST' && !moment(picklistValue).isBefore(moment().add(stringParts[2].toLowerCase(), parseInt(stringParts[1])*-1), stringParts[2].slice(0, -1).toLowerCase())) {
			                        	fromMatches = true;
			                        }
			                        else {
			                        	return;
			                        }
			                    }
	                        }
	                        else if (stringParts[2] == 'AGO' || stringParts[2] == 'FROM') {
	                        	var stringPartsValue = parseInt(stringParts[0]);
	                        	var stringPartsUnit = stringParts[1].toLowerCase();
	                        	if (!isNaN(stringPartsValue) && $.inArray(stringPartsUnit, ['days', 'years']) != -1) {
	                        		fromIsDateLiteral = true;
	                        		var stringPartsEnd = stringParts[2] + (stringParts[3] ? ' ' + stringParts[3] : '');
	                        		if (stringPartsEnd == 'AGO') {
	                        			if (!moment(picklistValue).isBefore(moment().add(stringPartsUnit, stringPartsValue*-1), stringPartsUnit.slice(0, -1))) {
	                        				fromMatches = true;
	                        			}
	                        			else {
	                        				return;
	                        			}
	                        		}
	                        		else if (stringPartsEnd == 'FROM NOW') {
	                        			if (!moment(picklistValue).isBefore(moment().add(stringPartsUnit, stringPartsValue), stringPartsUnit.slice(0, -1))) {
	                        				fromMatches = true;
	                        			}
	                        			else {
	                        				return;
	                        			}
	                        		}
	                        	}
		                    }
	                    }
	                    catch (err) { }
	                    
	                    //check if the to value is a dynamic date literal
	                    try {
	                        var stringParts = rule.enddate.split(' ');
	                        if (stringParts[0] == 'NEXT' || stringParts[0] == 'LAST') {
	                        	if (!isNaN(parseInt(stringParts[1])) && stringParts.length == 3 && $.inArray(stringParts[2], ['DAYS', 'QUARTERS', 'YEARS']) != -1) {
	                        		toIsDateLiteral = true;
			                        if (stringParts[0] == 'NEXT' && !moment(picklistValue).isAfter(moment().add(stringParts[2].toLowerCase(), parseInt(stringParts[1])), stringParts[2].slice(0, -1).toLowerCase())) {
	                                    toMatches = true;
			                        }
			                        else if (stringParts[0] == 'LAST' && !moment(picklistValue).isAfter(moment(), stringParts[2].slice(0, -1).toLowerCase())) {
			                        	toMatches = true;
			                        }
			                        else {
			                        	return;
			                        }
			                    }
	                        }
	                        else if (stringParts[2] == 'AGO' || stringParts[2] == 'FROM') {
	                        	var stringPartsValue = parseInt(stringParts[0]);
	                        	var stringPartsUnit = stringParts[1].toLowerCase();
	                        	if (!isNaN(stringPartsValue) && $.inArray(stringPartsUnit, ['days', 'years']) != -1) {
	                        		toIsDateLiteral = true;
	                        		var stringPartsEnd = stringParts[2] + (stringParts[3] ? ' ' + stringParts[3] : '');
	                        		if (stringPartsEnd == 'AGO') {
	                        			if (!moment(picklistValue).isAfter(moment().add(stringPartsUnit, stringPartsValue*-1), stringPartsUnit.slice(0, -1))) {
	                        				toMatches = true;
	                        			}
	                        			else {
	                        				return;
	                        			}
	                        		}
	                        		else if (stringPartsEnd == 'FROM NOW') {
	                        			if (!moment(picklistValue).isAfter(moment().add(stringPartsUnit, stringPartsValue), stringPartsUnit.slice(0, -1))) {
	                        				toMatches = true;
	                        			}
	                        			else {
	                        				return;
	                        			}
	                        		}
	                        	}
		                    }
	                    }
	                    catch (err) { }
	                    
	                    //handle non date literals
	                    if (!fromIsDateLiteral && (picklistValue == '' || picklistValue.split('T')[0] >= rule.comparevalue)) {
                   			fromMatches = true;
                   		}
                   		if (!toIsDateLiteral && (picklistValue == '' || picklistValue.split('T')[0] <= rule.enddate)) {
                   			toMatches = true;
                   		}
                    
                    	//check if this is a match
                    	if (toMatches && fromMatches) 
                    	{
                    		markerColor = rule.value;
       						foundMatch = true;
       						matchedindex = index;
                    	}
           			}  			
           		});
           		
           		//was a match found?
           		if(!foundMatch)
       			{
       			    //console.log('picklistValue: ' + picklistValue);
       			    
       				markerColor = otherColor;
       				
       				//update the legend marker count for <Other>
	           		var $legendRow = record.plottedQuery.find('.legend-row.other');
	           		if (!options.isForCluster && !options.isForScatter) {
	           			$legendRow.data('numMarkers', $legendRow.data('numMarkers') + 1);
	           		}
	           		
	           		//store the legend row with the record for easy access later
	           		record.legendRow = $legendRow;
       			}
       			else
       			{
       				//increment legend row for this rule
       				var $legendRow = record.plottedQuery.find('.legend-checkbox[data-rule="'+matchedindex+'"]').closest('.legend-row');
       				if (!options.isForCluster && !options.isForScatter) {
       					$legendRow.data('numMarkers', $legendRow.data('numMarkers') + 1);
       				}
            	
            		//store the legend row with the record for easy access later
       				record.legendRow = $legendRow;
     			}
            }
            else if (markerMetadata.ColorAssignmentType == 'Dynamic-Label')
            {
            	markerColor = '--Label--';
            }
            else if (markerMetadata.ColorAssignmentType == 'Dynamic-Order')
            {
            	markerColor = '--Order--';
            }
            else
           	{
           		//this should never happen, but if we don't have a color for this value and we don't have a color for <Other>, then just make the marker black
           		markerColor = '#000000';
           	}
		
			//create marker options
			var MarkerCoordinate = new google.maps.LatLng(parseFloat(record.markerLatitude), parseFloat(record.markerLongitude));         
		    var markerOptions = {
		        title: String(tooltip1Value),
		        visibility: true,
		        brush: markerColor,
		        Ignore: false, 
		        SavedQryId: record.savedQueryId,
		        Lat: record.markerLatitude,
		        Long: record.markerLongitude,
		        PicklistFieldValue: null,
		        record: record
		    };
		    
		    //console.log(markerOptions);
		    
		    //create either an image marker or a standard marker depending on the markerColor value
		    if (options && options.markerType == 'Waypoint')
            {
            	var waypointMarker;
				if (!(window.ActiveXObject) && "ActiveXObject" in window) {
					waypointMarker = new RichMarker($.extend(markerOptions, {
						map: MA.map,
						position: MarkerCoordinate,
		                anchor: RichMarkerPosition.BOTTOM,
		                flat: true,
		                zIndex: 1000,
		                content: $('#templates .svg-marker-waypoint').clone().wrap('<div/>').parent().html().replace(/__INDEX__/g, record.record.Id).replace(/__TEXT__/g, options.index),
		            }));
				}
				else {
        			waypointMarker = new google.maps.Marker($.extend(markerOptions, {
	        			map: MA.map,
	        			position: MarkerCoordinate,
        				icon: {
        					url: 'data:image/svg+xml;base64,' + CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse($('#templates .svg-marker-waypoint').clone().wrap('<div/>').parent().html().replace(/__INDEX__/g, record.record.Id).replace(/__TEXT__/g, options.index))),
							anchor: new google.maps.Point(14, 42)
						},
        				layerType: 'waypoint-marker',
        				zIndex: 1000
	        		}));
        		}
        		google.maps.event.addListener(waypointMarker, 'click', function (e) { marker_Click.call(this); });

        		return waypointMarker;
            }
		    else if (markerColor && markerColor.indexOf('image:') == 0)
			{
				//make sure we have the dimensions for the image and then create and return the marker
			    if (imgLoaderDimensions[markerColor.split('image:')[1]])
			    {
					//create marker
					var marker = new google.maps.Marker($.extend(markerOptions, {
						position: MarkerCoordinate,
						icon: {
							url: MA.SitePrefix+'/servlet/servlet.FileDownload?file=' + markerColor.split('image:')[1],
							anchor: new google.maps.Point(imgLoaderDimensions[markerColor.split('image:')[1]].width/2, imgLoaderDimensions[markerColor.split('image:')[1]].height)
						},
						layerType: 'query-marker'
					}));

					//handle right click (left click is handled by MA.Map.spiderfier)
					google.maps.event.addListener(marker, 'rightclick', function (e) { marker_Context.call(this, e) });
					
					return marker;
			    }
			}
			else if (markerColor && markerColor.indexOf('--Label--') == 0)
			{
			    
			    //console.log(queryMetadata.advancedOptions);
			    
				//get the proper label
				//console.log(tooltip1Value);
				if(String(tooltip1Value) == '') {
					tooltip1Value = 'N/A';
					//console.log('i am blank now');
				}
				else if(tooltip1Value.length > 40) {
					tooltip1Value = tooltip1Value.substring(0, 40).concat('...');
				}

				//get the proper width
				var $textWidthEl = $('<svg><text style="font-size:14px;">'+tooltip1Value+'</text></svg>').appendTo('#invisible');
				var width = $textWidthEl.find('text')[0].getComputedTextLength() + 12;
				$textWidthEl.remove();
					
				//start building the icon svg
				var iconSVG = 
					'<svg width="__WIDTH__px" height="__HEIGHT__px" xmlns="http://www.w3.org/2000/svg">' +
						'<rect x="__X__" y="__Y__" width="__RECT_WIDTH__px" height="__RECT_HEIGHT__px" style="fill:__BRUSH__;fill-opacity:0.6;stroke:__STROKE__;stroke-width:__STROKEWIDTH__;"/>' +
						'<text x="__OFFSETX__" y="__OFFSETY__" fill="__TEXT_PEN__" style="font-size:__FONTSIZE__;">__TEXT__</text>' +
					'</svg>'
					
				//replace svg parts with updated info
				iconSVG = iconSVG.replace(/__TEXT__/g, $('<div/>').text(tooltip1Value).html().replace(/"/g, '&quot;'))
					.replace(/__FONTSIZE__/g, 14)
					.replace(/__BRUSH__/g, "#000000")
					.replace(/__STROKE__/g, "#FFF")
					.replace(/__STROKEWIDTH__/g, 1)
					.replace(/__TEXT_PEN__/g, "#FFF")
					.replace(/__WIDTH__/g, width + 1)
					.replace(/__HEIGHT__/g, 21 + 1)
					.replace(/__RECT_WIDTH__/g, width)
					.replace(/__RECT_HEIGHT__/g, 21)
					.replace(/__OFFSETX__/g, 6)
					.replace(/__OFFSETY__/g, 15)
					.replace(/__OPACITY__/g, .5)
					.replace(/__X__/g, 1 / 2)
					.replace(/__Y__/g, 1 / 2);
					
				//measure the icon
				var $iconToMeasure = $(iconSVG).appendTo($('#invisible'));
				var iconWidth = $iconToMeasure.width();
				var iconHeight = $iconToMeasure.height();
				$iconToMeasure.remove();

				//create the marker
				var marker;
				/*
				if (!(window.ActiveXObject) && "ActiveXObject" in window) {
					marker = new RichMarker($.extend(markerOptions, {
						position: MarkerCoordinate,
		                anchor: RichMarkerPosition.MIDDLE,
		                flat: true,
		                content: iconSVG
		            }));
				}
				else {
					marker = new google.maps.Marker($.extend(markerOptions, {
						position: MarkerCoordinate,
						icon: {
							url: 'data:image/svg+xml;base64,'+CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(iconSVG)),
							anchor: new google.maps.Point(iconWidth/2, iconHeight)
						},
						layerType: 'query-marker'
					}));
				}
				*/
				
				var markerLabelTextColor = (advancedOptions.all.markerLabelTextColor) ? advancedOptions.all.markerLabelTextColor : '#cccccc';
				var markerLabelBackgroundColor = (advancedOptions.all.markerLabelBackgroundColor) ? advancedOptions.all.markerLabelBackgroundColor : '#000000';
				
				
				styleIcon = new StyledIcon(StyledIconTypes.BUBBLE,{
				    color: markerLabelBackgroundColor,
				    fore: markerLabelTextColor,
				    text: encodeURIComponent(tooltip1Value)
				});
                marker = new StyledMarker($.extend(markerOptions, {
                    styleIcon:styleIcon,
                    position:MarkerCoordinate,
                    draggable:false,
                    layerType: 'query-marker'
                }));

				//handle right click (left click is handled by MA.Map.spiderfier)
				google.maps.event.addListener(marker, 'rightclick', function (e) { marker_Context.call(this, e) });

				return marker;
			}
			else if (markerColor && markerColor.indexOf('--Order--') == 0)
			{
				//get the proper width
				var text = String(record.index + 1);
				var $textWidthEl = $('<svg><text style="font-size:14px;">'+text+'</text></svg>').appendTo('#invisible');
				var width = $textWidthEl.find('text')[0].getComputedTextLength() + 16;
				$textWidthEl.remove();

				//start building the icon svg
				var iconSVG = 
					'<svg width="__WIDTH__" height="__HEIGHT__" xmlns="http://www.w3.org/2000/svg">' +
						'<ellipse opacity="0.65" cx="__X__" cy="__Y__" rx="__RECT_WIDTH__" ry="__RECT_HEIGHT__" style="fill:__BRUSH__;stroke:__STROKE__;stroke-width:__STROKEWIDTH__;"/>' +
						'<text x="__OFFSETX__" y="__OFFSETY__" fill="__TEXT_PEN__" style="font-size:14px;">__TEXT__</text>' +
					'</svg>';
					
				//replace svg parts with updated info
				iconSVG = iconSVG.replace(/__TEXT__/g, text)
					.replace(/__BRUSH__/g, "#000070")
					.replace(/__STROKE__/g, "#FFF")
					.replace(/__STROKEWIDTH__/g, 1)
					.replace(/__TEXT_PEN__/g, "#FFF")
					.replace(/__WIDTH__/g, width)
					.replace(/__HEIGHT__/g, 20)
					.replace(/__RECT_WIDTH__/g, width/2)
					.replace(/__RECT_HEIGHT__/g, 10)
					.replace(/__OFFSETX__/g, 8)
					.replace(/__OFFSETY__/g, 14.5)
					.replace(/__X__/g, width/2)
					.replace(/__Y__/g, 10);
					
				//measure the icon
				var $iconToMeasure = $(iconSVG).appendTo($('#invisible'));
				var iconWidth = $iconToMeasure.width();
				var iconHeight = $iconToMeasure.height();
				$iconToMeasure.remove();

				//create the marker
				var marker;
				if (!(window.ActiveXObject) && "ActiveXObject" in window) {
					marker = new RichMarker($.extend(markerOptions, {
						position: MarkerCoordinate,
		                anchor: RichMarkerPosition.MIDDLE,
		                flat: true,
		                content: iconSVG
		            }));
				}
				else {
					marker = new google.maps.Marker($.extend(markerOptions, {
						position: MarkerCoordinate,
						icon: {
							url: 'data:image/svg+xml;base64,'+CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(iconSVG)),
							anchor: new google.maps.Point(iconWidth/2, iconHeight/2)
						},
						layerType: 'query-marker'
					}));
				}

				//handle right click (left click is handled by MA.Map.spiderfier)
				google.maps.event.addListener(marker, 'rightclick', function (e) { marker_Context.call(this, e) });

				return marker;
			}

			//create marker
			var markerColorParts = markerColor.split(':');
            var markerShape = MA.Marker.shapes[markerColorParts[1] || 'Marker'];
			var marker;

			//check if scatter
			if(options.isForScatter) 
			{
				marker = new google.maps.Marker($.extend(markerOptions, {
					position: MarkerCoordinate,
					icon: {
						path: google.maps.SymbolPath.CIRCLE,
						fillColor: markerColorParts[0],
						fillOpacity : 1,
						strokeColor : '#282828',
						strokeWeight : 1,
						scale: 7
					}
				}));

				google.maps.event.addListener(marker, 'click', function (e) { marker_Click.call(this); });
			}
			else 
			{
			     //not for scatter
			    
			    if ('{!ImageServerEnabled}' == 'true')
			    {
			        //console.log('markerColor: ' + markerColor);
			        //markerURL = 'https://product-api-prod.cloudbilt.com/marker/marker.php?marker=' + markerColor.replace('#','');
			        
			        
			        var markerInfoForImageServer = markerColor.replace('#','');
			        if (markerInfoForImageServer.indexOf(':') < 0) //this is for legacy support for when there was no marker "type" (example: marker,square, etc)
			        {
			            markerInfoForImageServer += ':Marker';
			        }
			        
			        
			        
			        marker = new google.maps.Marker($.extend(markerOptions, {
						position: MarkerCoordinate,
						icon: {
							url: 'https://product-api-prod.cloudbilt.com/marker/marker.php?marker=' + markerInfoForImageServer,
							anchor: options.isForScatter ? new google.maps.Point(8,8) : markerShape.anchor
						},
						layerType: 'query-marker'
					}));
			    }
			    else
			    {
			        if (!(window.ActiveXObject) && "ActiveXObject" in window) 
    				{
    					//check if we have created this url before
    					var markerURL;
    					if(MA.cachedMarkers[markerColor]) 
    					{
    						markerURL = MA.cachedMarkers[markerColor];
    					}
    					else 
    					{
    						markerURL = MA.Marker.createSVG({ type: options.isForScatter ? 'Scatter' : 'Marker', color: markerColor });
    
    						//add to cache
    						MA.cachedMarkers[markerColor] = markerURL;
    					}
    
    					marker = new RichMarker($.extend(markerOptions, {
    						position: MarkerCoordinate,
    		                anchor: options.isForScatter ? new google.maps.Point(8,8) : markerShape.anchor.Rich,
    		                flat: true,
    		                content: markerURL
    		            }));
    				}
    				else 
    				{
    					//check if we have created this url before
    					var markerURL;
    					if(MA.cachedMarkers[markerColor]) 
    					{
    						markerURL = MA.cachedMarkers[markerColor];
    					}
    					else 
    					{
    						markerURL = 'data:image/svg+xml;base64,'+CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(MA.Marker.createSVG({ type: options.isForScatter ? 'Scatter' : 'Marker', color: markerColor })));

    						//add to cache
    						MA.cachedMarkers[markerColor] = markerURL;
    					}
    
    					marker = new google.maps.Marker($.extend(markerOptions, {
    						position: MarkerCoordinate,
    						icon: {
    							url: markerURL,
    							anchor: options.isForScatter ? new google.maps.Point(8,8) : markerShape.anchor
    						},
    						layerType: 'query-marker'
    					}));
    				}
			    }
				
			}

			//handle right click (left click is handled by MA.Map.spiderfier)
			google.maps.event.addListener(marker, 'rightclick', function (e) { marker_Context.call(this, e) });
			
			return marker;
		}

		function waypoint_Click(options)
        {
        	options = $.extend({
        		markerType: 'waypoint'
        	}, options || {});
        
        	var marker = this;
        	//start building tooltip content from template
            var $waypointContent = $('#waypoint-content-template').clone().attr('id', 'waypoint-content');

            $waypointContent.find('.name').text(marker.dataName || '');
            $waypointContent.find('.address').text(marker.dataAddress || '');

            //launch infobubble
		 	MA.Map.InfoBubble.show({
		 		position: marker.getPosition(),
		 		anchor: marker,
		 		minWidth: 300,
				maxWidth: 300,
		 		content: $waypointContent.get(0)
		 	});
        }
		
		function marker_Click(options)
        {
        	options = $.extend({
        		markerType: 'marker'
        	}, options || {});
        
        	var marker = this;
        	
            var record = this.record;
            var queryMetadata = record.plottedQuery.data();

            //start building tooltip content from template
            var $tooltipContent = $('#tooltip-content-template').clone().attr('id', 'tooltip-content');
            
            //show related list tab if needed
            if (queryMetadata.relatedListCount > 0) { 
                $tooltipContent.find('#tab-relatedlist').show(); 
            }
            
            //show weather tab if needed
            if (userSettings.ShowWeather) {
            	$tooltipContent.find('#tab-weather').show();
            }
            
            //show picklist field info if needed 
            if (queryMetadata.markerMetadata.ColorAssignmentType == 'Dynamic, Field') { 
                $tooltipContent.find('.picklistinfo').show(); 
            }
            
            //show dynamic order if needed
            if (queryMetadata.markerMetadata.ColorAssignmentType == 'Dynamic-Order') {
            	var recordIndex = record.index + 1;
            	var recordIndexPixelOffset = (((recordIndex+'').length - 1) * 5) + 8;
            	$tooltipContent.find('.tooltip-header').css('padding-left',  recordIndexPixelOffset+'px').append("<div class='tooltip-header-order'>"+recordIndex+"</div>");
            }
            
            //add tooltips
            var $tooltips = $tooltipContent.find('.tooltips > table');
            var tooltip1Value = 'Tooltip 1';
            $.each(queryMetadata.tooltips, function (index, tooltip) 
            {
       			//if this is the first tooltip, keep track of the value for use later.  otherwise, append it to the tooltips
            	if (index == 0)
            	{
            		tooltip1Value = extractTooltipValue(tooltip, record);
            	}
            	else
            	{
            		//create a new tooltip row
            		var $newTooltip = $("<tr class='tooltip-row'><td class='icon'></td><td class='label'><b>"+tooltip.FieldLabel+"</b></td><td class='value'>"+extractTooltipValue(tooltip, record)+"</td><td class='tooltip-loader'><img class='saving' src=\"{!URLFOR($Resource.MapAnything, '/images/chatterstatus-loader.gif')}\" /><img class='error' src=\"{!URLFOR($Resource.MapAnything, 'images/x-22.png')}\" title='Unable to save' /></td></tr>");
            		if (tooltip.TooltipType != 'Tooltip') {
            			$newTooltip.find('.icon').attr('title', tooltip.TooltipType + ' field');
            		}
            		
            		//make this tooltip editable if needed
            		if (userSettings.EditableTooltips && tooltip.Accessible && tooltip.Updateable && displayTypeMetadata[tooltip.DisplayType]) {
            			$newTooltip.find('td.value').addClass('editable');
            		}
            		
            		//if this tooltip row is for a textarea, allow wrapping
            		if (tooltip.DisplayType == 'TEXTAREA') {
            			$newTooltip.find('td.label').css('vertical-align', 'top');
            			$newTooltip.find('td.value').css('white-space', 'normal');
            		}
            		
            		//append this new row to the tooltips table
            		$newTooltip.addClass(tooltip.TooltipType).appendTo($tooltips).data('tooltip', tooltip);
            	}
            });

			//populate template merge fields
			$tooltipContent = $(
				$tooltipContent.wrap('<div></div>').show().parent().html()
	                .replace(/::ContentKey::/g, record.contentKey)
	                .replace(/\/::Id::/g, MA.SitePrefix+'/'+record.record.Id)
	                .replace(/::Name::/g, tooltip1Value)
	                .replace(/::Address::/g, record.markerAddress)
	                .replace(/::PicklistFieldLabel::/g, 'PicklistFieldLabel')
	                .replace(/::PicklistFieldValue::/g, 'PicklistFieldValue')
            );

			//launch infobubble
		 	MA.Map.InfoBubble.show({
		 		position: this.getPosition(),
		 		anchor: marker,
		 		minWidth: 420,
		 		content: $tooltipContent.get(0)
		 	});

		 	//show chatter tab if needed
            if (queryMetadata.supportsChatter) {
                $tooltipContent.find('#tab-chatter').show().data('recordId', record.record.Id).data('contentKey', record.contentKey).data('loaded', false);
            }
            
            //load related list integration
            if (queryMetadata.relatedListCount > 0)
            {
                $tooltipContent.find("#ajax-" + record.contentKey)
                    .html("{!$Label.MA_Loading}")
                    .load(MA.resources.RelatedLists,"parentid=" + record.record.Id + '&sqid=' + queryMetadata.id, function () { MA.Map.InfoBubble.adjust(); });  
            }
                            
            //init tabs
            function tabCreateActivate (event, ui)
            {
            	var panel = ui.newPanel || ui.panel || { selector: '' };

            	//handle clicking the weather tab
                if (panel.selector.indexOf('pane-weather') > -1)
                {
                    //build a request url 
                    var AJAXURL = "https://api.aerisapi.com/forecasts/closest?p=[lat],[log]&client_id=aMmtNIJO93b1YWgxPPzjw&client_secret=N4Bbg4p2hMMhXgO7NgNwGxTjHxbG0DbMeq9YZhPo"
                    	.replace('[lat]',marker.Lat)
                    	.replace('[log]',marker.Long);
                    
                    //show loading
                    $('#weather-ajax-' + record.contentKey).html("{!$Label.MA_Loading}...");
                            
                    //send request to get weather content
                    $.ajax({
                        url: AJAXURL,
                        dataType: "jsonp",
                        success: function(json) {
                        	var WeatherIconURL = "{!$Resource.WeatherIcons}";
							$.each(json.response[0].periods, function(index, value) {
                               	
								var WeatherObj = value;
	                           	var WeatherDate = new Date(value.timestamp * 1000);
	                           	if (index == 0)
	                           	{
                                	$('#weather-ajax-' + record.contentKey).html(
                                    	$('#CurrentLocationWeatherTemplate').clone().html()
											.replace(/::date::/g, WeatherDate.toLocaleDateString())
                                            .replace(/::maxTempF::/g, WeatherObj['maxTempF'])
                                            .replace(/::maxTempC::/g, WeatherObj['maxTempC'])
                                            .replace(/::minTempC::/g, WeatherObj['minTempC'])
                                            .replace(/::minTempF::/g, WeatherObj['minTempF'])
                                            .replace(/::avgTempF::/g, WeatherObj['avgTempF'])
                                            .replace(/::feelslikeF::/g, WeatherObj['feelslikeF'])
                                            .replace(/::icon::/g, '<img src="' + WeatherIconURL + '/' + WeatherObj['icon'] + '" />')
                                            .replace(/::weather::/g, WeatherObj['weather'])
                                            .replace(/::pop::/g, WeatherObj['pop'])
                                            .replace(/::humidity::/g, WeatherObj['humidity'])
                                            .replace(/::windDir::/g, WeatherObj['windDir'])
                                            .replace(/::windSpeedMPH::/g, WeatherObj['windSpeedMPH'])
									);
                               	}
                               	else
                               	{
                                	$('#weather-ajax-' + record.contentKey).append(
                                    	$('#LocationWeatherTemplate').clone().html()
                                        	.replace(/::date::/g, WeatherDate.toLocaleDateString())
                                            .replace(/::maxTempF::/g, WeatherObj['maxTempF'])
                                            .replace(/::maxTempC::/g, WeatherObj['maxTempC'])
                                            .replace(/::minTempC::/g, WeatherObj['minTempC'])
                                            .replace(/::minTempF::/g, WeatherObj['minTempF'])
                                            .replace(/::icon::/g, '<img src="' + WeatherIconURL + '/' + WeatherObj['icon'] + '" />')
                                            .replace(/::weather::/g, WeatherObj['weather'])
                                            .replace(/::pop::/g, WeatherObj['pop'])
                                            .replace(/::humidity::/g, WeatherObj['humidity'])
                                            .replace(/::windDir::/g, WeatherObj['windDir'])
                                            .replace(/::windSpeedMPH::/g, WeatherObj['windSpeedMPH'])
									);
                                }
                            });

							MA.Map.InfoBubble.adjust();
                        }
                    });
                }
                else if (panel.selector.indexOf('pane-chatter') > -1) {
                	if (!$tooltipContent.find('#tab-chatter').data('loaded')) 
                    {
                        //mark as loaded so we don't load again
                        $tooltipContent.find('#tab-chatter').data('loaded', true);
                        
                        //load chatter integration
                        $tooltipContent.find('#pane-chatter-'+$tooltipContent.find('#tab-chatter').data('contentKey')).append("<iframe src='"+MA.resources.ChatterFeed+"?entityId="+$tooltipContent.find('#tab-chatter').data('recordId')+"' style='width: 100%; height: 300px; border: none;'></iframe>");
                    }
                    MA.Map.InfoBubble.adjust();
                }
                else {
                	MA.Map.InfoBubble.adjust();
                }
            }
            $tooltipContent.find('.tabs').tabs({
            	active: queryMetadata.advancedOptions ? $tooltipContent.find('#tab-' + (queryMetadata.advancedOptions.defaultTab || 'info')).index() : 0,
            	create: tabCreateActivate,
                activate: tabCreateActivate
            });
            
            //init tooltip rows
            $tooltipContent.find('.tooltip-row').each(function () {
            	$(this).data('saveTimeouts', []);
            });
            
            //handle clicking links in tooltips (need to stop propagation so the links will fire instead of editing the tooltip)
            $tooltipContent.on('click', '.tooltip-row td.value a', function (e) {
            	e.stopPropagation();
            });
            
            //handle clicking to edit tooltips
            $tooltipContent.on('click', '.tooltip-row td.value.editable', function () {
            
            	//close any existing picklist fields by clicking the html element
            	$('html').click();
            
            	var $tooltipRow = $(this).closest('.tooltip-row');
            	var tooltipMetadata = queryMetadata.tooltips[$tooltipRow.index() + 1];
            	var $valueCell = $(this).removeClass('editable').addClass('editing');
            	var fieldValue = extractValue(record.record, tooltipMetadata.ActualFieldName);
            	var editType = displayTypeMetadata[tooltipMetadata.DisplayType] ? displayTypeMetadata[tooltipMetadata.DisplayType].editType : '';
            	var renderType = displayTypeMetadata[tooltipMetadata.DisplayType] ? displayTypeMetadata[tooltipMetadata.DisplayType].renderType : '';
            	switch (editType)
            	{
            		case 'string':
            		
	            		$valueCell.html("<input type='text' value='"+fieldValue+"' />").find('input').data('originalValue', fieldValue+'').focus().blur(function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
            			break;
            			
            		case 'number':
            		
	            		$valueCell.html("<input type='text' value='"+fieldValue+"' />").find('input').data('originalValue', fieldValue+'').focus().blur(function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
            	
            		case 'textarea':
            		
	            		$valueCell.html($("<textarea />").val($valueCell.text()).width($valueCell.width()+'px')).find('textarea').data('originalValue', fieldValue+'').focus().select().blur(function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
            		
            		case 'picklist':
            		
	            		var $picklistOptions = $('<select class="combobox" />');
	            		$.each(tooltipMetadata.PicklistOptions, function (index, option) {
	            			$picklistOptions.append($('<option />').attr('value', option.value).text(option.label));
	            		});
	            		$picklistOptions.val($valueCell.text());
	            		
	            		$valueCell.html($picklistOptions).find('.combobox').combobox().next().click(function () {return false;}).find('input').data('originalValue', fieldValue+'').focus().select();
	            		
	            		
	            		$('html').one('click', function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
	            		
	            	case 'multipicklist':
	            		
	            		var $picklistOptions = $('<select class="multiselect" />');
                        $.each(tooltipMetadata.PicklistOptions, function (index, option) {
							$picklistOptions.append($('<option />').attr('value', option.value).text(option.label).attr('checked', (';'+fieldValue+';').indexOf(option.value) != -1));
                        });
                        
                        $valueCell.html($picklistOptions).find('.multiselect').multiselect({
                            noneSelectedText: 'Click here to select options',
                            selectedList: 2,
                            close: function () {
                            	$('html').click();
                            }
                        }).multiselectfilter().multiselect('uncheckAll').multiselect('widget').click(function (e) { e.stopPropagation(); });
                        
                        $('html').one('click', function () {
                        
                        	//save
                       		$picklistOptions.data('newValue', $picklistOptions.multiselect('getChecked').map(function () {
                       			return this.value;
                       		}).get().join(';')).change();
                        
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
            	
            		case 'boolean':
            		
	            		$valueCell.html($("<input type='checkbox' />").attr('checked', $valueCell.text().toLowerCase() == 'true')).find('input').click(function (e) { e.stopPropagation();}).data('originalValue', fieldValue).focus();
	            		
	            		$('html').one('click', function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
	            		
	            	case 'date':
	            		////////////////////////Format Date Locale ///////////////////////////////
	            		var formatedDate = formatUserLocaleDate({datepicker	: true});
	            		////////////////////////Format Date Locale ///////////////////////////////
	            		
	            		$valueCell.html($("<input type='text' class='date' />").val($valueCell.text())).find('input').datepicker({ dateFormat: ""+formatedDate+"" }).focus().click(function (e) {e.stopPropagation();});
	            		
	            		//modified to not hide datepicker on month change
	            		$('html').on('click', function (e) {
	            			//if click on datepicker, do not hide
	            			if ($(e.target).is('[class^="ui-datepicker"]') == true || $(e.target).is('[class^="ui-icon"]') == true)
	            			{
	            				return false;
	            			}
	            			$('#ui-datepicker-div').hide();
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		
	            		
	            		break;
            		
            		case 'datetime':
	            		////////////////////////Format Date Locale ///////////////////////////////
	            		var formatedDate = formatUserLocaleDate({datepicker	: true});
	            		////////////////////////Format Date Locale ///////////////////////////////
	            		
	            		$valueCell.html($("<input type='text' class='datetime' />").val($valueCell.text())).find('input').datepicker({ dateFormat: ""+formatedDate+"" }).focus().click(function (e) {e.stopPropagation();});
	            		
	            		//modified to not hide datepicker on month change
	            		$('html').on('click', function (e) {
	            			//if click on datepicker, do not hide
	            			if ($(e.target).is('[class^="ui-datepicker"]') == true || $(e.target).is('[class^="ui-icon"]') == true)
	            			{
	            				return false;
	            			}
	            			$('#ui-datepicker-div').hide();
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		
	            		
	            		break;
            		
            		case 'reference':
            		
            			var $lookupWrapper = $('<div class="autocomplete-wrapper"><input type="text" class="autocomplete" /><div class="autocomplete-clear">x</div></div>')
	            		var $lookup = $lookupWrapper.find('input');
	            		$valueCell.html($lookupWrapper).find('input').click(function (e) { e.stopPropagation(); }).focus().data('originalValue', fieldValue);
	            		$valueCell.find('.autocomplete-clear').click(function (e) { $lookup.data('selectedItem', { value: '', label: '' }); });
	            		
	            		$lookup.autocomplete({
	            			focus: function (event, ui) {
	            				$lookup.val(ui.item.label);
	            				return false;
	            			},
	                		select: function (event, ui) {
	                			$lookup.val(ui.item.label).data('selectedItem', ui.item);
	                			event.stopPropagation();
	                			return false;
	                		},
	                		search: function () {
	                			$lookup.addClass('searching');
	                		},
	                		source: function(request, response) {
						        $.ajax({
			           				url: MA.resources.Tooltip+'?action=get_lookup_options',
							        type: 'POST',
							        dataType: 'JSON',
							        data: {
							        	baseObject: tooltipMetadata.BaseObject,
							        	fieldName: tooltipMetadata.ActualFieldName,
							        	term: request.term
							        },
							        success: function (successResponse)
							        {
							            if (!successResponse.success)
							            {
							            	response([]);
							            	return;
							            }
							            
							            response(successResponse.lookupOptions);
							        },
							        error: function () 
							        {
							        	response([]);
							        },
							        complete: function ()
							        {
							        	$lookup.removeClass('searching');
							        }
			           			});
						    }
	                	});
	                	
	                	$('html, #tooltip-content').one('click', function () {
	                		var $inputField = $valueCell.find('input');
	                		if ($inputField.data('selectedItem') && $inputField.data('selectedItem').value != $inputField.data('originalValue')) {
	                			$inputField.change();
	                		}
	                	
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
	            		
	            	default:

	            		//no matching type so do nothing
	            		$valueCell.removeClass('editing').addClass('editable');
	            		return;
	            }
            	
            	//handle pressing tab or enter on an input
            	$valueCell.find('input, textarea').keydown(function (e) {
            		if (e.keyCode == 9) {
            		
            			//find the next element that we want to move focus to by moving forward or backward through the tooltip rows and looking for an editable value
            			var $nextTooltipRow = $(this).closest('.tooltip-row');
            			var $nextElement;
            			while ($nextTooltipRow.length > 0)
            			{
            				$nextTooltipRow = e.shiftKey ? $nextTooltipRow.prev() : $nextTooltipRow.next();
	            			$nextElement = $nextTooltipRow.find('td.value.editable');
	            			if ($nextElement.length > 0) {
	            				break;
	            			}
            			}
            			
            			//fire the change event if the user has changed the value
            			var inputValue = $(this).is('[type="checkbox"]') ? $(this).is(':checked') : $(this).val();
            			if ($(this).data('originalValue') != inputValue) {
            				$(this).change();
            			}
            			
            			//remove focus from this element and click the next one
            			$(this).blur();
            			$('html').click();
            			$nextElement.click();
            			
            			//cancel the default behavior
            			return false;
            		}
            		else if (e.keyCode == 32 && $(this).is('[type="checkbox"]')) {
            			$(this).attr('checked', !$(this).is(':checked'));
            			return false;
            		}
            	});
            	$valueCell.find('input, textarea').keypress(function (e) {
            		if (e.keyCode == 13) {
            		
            			//fire the change event if the user has changed the value
            			var inputValue = $(this).is('[type="checkbox"]') ? $(this).is(':checked') : $(this).val();
            			if ($(this).data('originalValue') != inputValue) {
            				$(this).change();
            			}
            			
            			//remove focus from this element
            			$(this).blur();
            			$('html').click();
            		}
            	});
            	
            	return false;
            	
            });
            
            //handle actually editing tooltips
            $tooltipContent.on('change', '.tooltip-row td.value.editing input, .tooltip-row td.value.editing textarea, .tooltip-row td.value.editing select', function () {

				//gather some basic info about the input field, the tooltip row, and the metadata we have for this tooltip
            	var $inputField = $(this);
            	var $tooltipRow = $inputField.closest('.tooltip-row').addClass('saving').removeClass('error');
            	var tooltipMetadata = queryMetadata.tooltips[$tooltipRow.index() + 1];
            	
            	//figure out the current value of this field based on the type
            	var inputValue = '';
            	var inputValueName = '';
            	if ($inputField.is('[type="checkbox"]'))
            	{
            		 inputValue = $inputField.is(':checked');
            	}
            	else if ($inputField.is('.autocomplete'))
            	{
            		try {
            			inputValue = $inputField.data('selectedItem').value;
            			inputValueName = $inputField.data('selectedItem').label;
            			
            			//remove the selected item to avoid future searching from being considered a valid change
            			$inputField.data('selectedItem', null);
            		}
            		catch (err) 
            		{
            			//this failure means that the value has not yet been selected and this is part of the search function.  do nothing in this case
            			$tooltipRow.removeClass('saving');
            			return false;
            		}
            	}
            	else if ($inputField.is('.multiselect'))
            	{
            		//for a multiselect, a single selection shouldn't trigger an update so wait until we have a new value (assigned by the html click handler for this type)
            		if (!$inputField.data('newValue')) {
            			$tooltipRow.removeClass('saving');
            			return false;
            		}
            		else {
            			inputValue = $inputField.data('newValue');
            			$inputField.data('newValue', null);
            		}
            	}
            	else if ($inputField.is('.datetime'))
            	{
            		inputValue = $inputField.val();
            		
            		//set proper save date format
            		var dateformat = formatUserLocaleDate({moment: true});
            		//update inputValue with date and time to match user selected locale
            		inputValue = moment(inputValue,dateformat).format(dateformat);
            	}
            	else
            	{
            		inputValue = $inputField.val();
            	}
            	
            	//clear any existing save timeouts for this field
            	var saveTimeouts = $tooltipRow.data('saveTimeouts');
            	$.each(saveTimeouts, function (index, saveTimeout) {
            	
            		try {
            			clearTimeout(saveTimeout);
            			while ($.inArray(saveTimeout, saveTimeouts) != -1)
			        	{
			        		saveTimeouts.splice($.inArray(saveTimeout, saveTimeouts));
			        	}
	            	}
	            	catch (err) { }
            	
            	});
            	
            	//set a timeout to save this field
            	var saveTimeout = setTimeout(function () {
            		
           			$.ajax({
           				url: MA.resources.Tooltip+'?action=save_tooltip',
				        type: 'POST',
				        dataType: 'JSON',
				        data: {
				        	recordId: record.record.Id,
				        	fieldName: tooltipMetadata.ActualFieldName,
				        	newValue: inputValue
				        },
				        success: function (response)
				        {
				            if (!response.success)
				            {
				            	$tooltipRow.addClass('error').find('img.error').attr('title', response.error);
				            	return;
				            }
				            
				            //update the underlying record (and the name field of the related object if this is a reference field)
				            updateValue(record.record, tooltipMetadata.ActualFieldName, extractValue(response.updatedRecord, tooltipMetadata.ActualFieldName));
				            if ($inputField.is('.autocomplete')) {
				            	updateValue(record.record, tooltipMetadata.FieldName, inputValueName);
				            }
				            
				            //update the displayed tooltip if we are no longer in edit mode
				            if (!$tooltipRow.find('td.value').is('.editing'))
				            {
				            	if (displayTypeMetadata[tooltipMetadata.DisplayType].renderType == 'html') {
				            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
				            	}
				            	else {
				            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
				            	}
				            }
				            
				            //update the marker if this was a marker field
				            if (!$tooltipRow.is('.Tooltip')) 
				            {
				            	//update current legend row
				            	record.legendRow.data('numMarkers', record.legendRow.data('numMarkers') - 1);
		                		record.legendRow.find('.visiblemarkers').text((parseInt(record.legendRow.find('.visiblemarkers').text()) || 0) - 1);
		                		record.legendRow.find('.totalmarkers').text((parseInt(record.legendRow.find('.totalmarkers').text()) || 0) - 1);
		                		if (record.legendRow.data('numMarkers') == 0) {
		                			record.legendRow.addClass('empty').hide();
		                			if (record.plottedQuery.find('.legend').css('display') != 'none') {
		                				record.plottedQuery.find('.legend-moreless').show();
		                			}
		                		}
				            	
				            	//remove the current marker and create the new one
				            	var $plottedQuery = record.plottedQuery;
				            	var oldMarker = record.marker;
				            	var oldClusterMarker = record.clusterMarker;
				            	var oldScatterMarker = record.scatterMarker;
				            	
				            	/*
				            	record.tooltip1 = null;
				            	record.tooltip2 = null;
				            	record.tooltip3 = null;
				            	record.tooltip4 = null;
				            	record.tooltip5 = null;
				            	record.tooltip6 = null;
				            	record.tooltip7 = null;
				            	record.tooltip8 = null;
				            	*/
				            	
				            	
				            	
				            	record.marker = CreateMarkerFromRecord(record);
				            	record.clusterMarker = CreateMarkerFromRecord(record, {isForCluster:true});
				            	record.scatterMarker = CreateMarkerFromRecord(record, {isForScatter:true});
				            	if ($plottedQuery.find('.renderButtons-button.markers').is('.on') && record.marker && record.isVisible) {
				            		MA.Map.spiderfier.removeMarker(record.marker);
		                            oldMarker.setMap(null);
		                            record.marker.setMap(MA.map);
		                            MA.Map.spiderfier.addMarker(record.marker);
		                        }
		                        if ($plottedQuery.find('.renderButtons-button.cluster').is('.on') && record.clusterMarker && record.isClustered) {
			                        $plottedQuery.data('clusterGroup').removeMarker(oldClusterMarker);
			                        $plottedQuery.data('clusterGroup').addMarker(record.clusterMarker);
		                        }
		                        if ($plottedQuery.find('.renderButtons-button.scatter').is('.on') && record.scatterMarker && record.isScattered) {
                                	oldScatterMarker.setMap(null);
                                	record.scatterMarker.setMap(MA.map);
                                }
				            	
				            	//update the new legend row
				            	record.legendRow.data('numMarkers', record.legendRow.data('numMarkers') + 1);
		                		record.legendRow.find('.visiblemarkers').text((parseInt(record.legendRow.find('.visiblemarkers').text()) || 0) + 1);
		                		record.legendRow.find('.totalmarkers').text((parseInt(record.legendRow.find('.totalmarkers').text()) || 0) + 1);
		                		record.legendRow.removeClass('empty').show();
		                		if (record.plottedQuery.find('.legend-row.empty').length == 0) {
		                			record.plottedQuery.find('.legend-moreless').hide();
		                		}
				            }
				        },
				        error: function (response) 
				        {
				        	$tooltipRow.addClass('error').find('img.error').attr('title', 'Unable to save');
				        },
				        complete: function ()
				        {
				        	//remove this timeout from the array of timeouts for this tooltip
				        	while ($.inArray(saveTimeout, saveTimeouts) != -1)
				        	{
				        		saveTimeouts.splice($.inArray(saveTimeout, saveTimeouts));
				        	}
				        	
				        	//if this was the last save timeout for this tooltip then we are no longer saving so remove the saving class
				        	if (saveTimeouts.length == 0) {
				        		$tooltipRow.removeClass('saving');
				        	}
				        }
           			});
           			
           		}, 1000);
           		
           		//store the timeout so it can be cleared later if needed
           		$tooltipRow.data('saveTimeouts').push(saveTimeout);
            	
            });
            
            //build actions layout using the button set settings
            if (!userSettings.ButtonSetSettings) {
            }
            else if (!userSettings.ButtonSetSettings.tooltipLayout) {
            }
            else {
				$tooltipContent.find('.layout-tooltip').html(
					MAActionFramework.buildLayoutFromContents(userSettings.ButtonSetSettings.tooltipLayout, {
						queryMetadata: queryMetadata,
						record: record,
						markerType: options.markerType
					})
				);
			}
            
            //handle clicking an action button
            $tooltipContent.find('.layout-tooltip .actionbutton').click(function (e) {
            	var $button = $(this);
            	var frameworkAction = $button.attr('data-type') == 'Custom Action'
					? MAActionFramework.customActions[$button.attr('data-action')] || null
					: MAActionFramework.standardActions[$button.attr('data-action')] || null;
            	
            	if (frameworkAction) {
       				switch (frameworkAction.Action)
       				{
       					case 'Iframe':
       					
       						//get a component index from the action framework to make this tab unique and build the iframe url 
       						var componentIndex = MAActionFramework.componentIndex++;
       						var iframeURL = frameworkAction.ActionValue 
       							+ (frameworkAction.ActionValue.indexOf('?') == -1 ? '?noparams' : '')
       							+ '&Button=' + encodeURIComponent(frameworkAction.Label)
       							+ '&RecordId=' + record.record.Id;
       						
       						//build the new tab and the corresponding pane
       						var $newTab = $("<li id='CustomTab-"+componentIndex+"'><a href='#pane-customaction-"+componentIndex+"'>"+frameworkAction.Label+"</a> <span class='ui-icon ui-icon-close'>Remove Tab</span></li>");
       						var $newPane = $("<div id='pane-customaction-"+componentIndex+"'><iframe src='"+iframeURL+"' style='width: 100%; height: 100%;'></iframe></div>");
       						
       						//append the tab and pane to the tooltip tabs and refresh
       						$('#tooltip-content').find('.ui-tabs-nav').append($newTab).closest('.tabs').append($newPane).tabs('refresh').find('#CustomTab-'+componentIndex+' a').click();
       						
       						//handle clicking the close button for this new tab
       						$newTab.css({'width': 'auto', 'padding-right': '5px'}).find('.ui-icon-close').css({'cursor': 'pointer', 'position': 'absolute', 'right': '0'}).click(function () {
       							if ($newTab.is('.ui-tabs-active')) {
       								$('#tooltip-content').find('.ui-tabs-nav > li:first-child a').click();
       							}
       							
       							$newTab.remove();
       							$newPane.remove();
       						});
       						break;
       						
       					case 'NewWindow':
       					  var options = {
                    recString : ''
                  };
                  if(frameworkAction.ActionValue.indexOf('{records}') >= 0) {
                    options.records = true;
                  }

                  var newURL = frameworkAction.ActionValue 
                      + (frameworkAction.ActionValue.indexOf('?') == -1 ? '?noparams' : '')
                      + '&Button=' + encodeURIComponent(frameworkAction.Label)
                      + '&RecordId=' + record.record.Id;
                  if(frameworkAction.Options.method == 'GET') {
                    if(frameworkAction.Options.addRecords) {
         						 newURL += '&'+frameworkAction.Options.paramName+'=' + record.record.Id;
                    }
                    window.open(newURL);
                    break;
                  }
                  else {

                    var postData = {};

                    if(frameworkAction.Options.addRecords) {
                      postData[frameworkAction.Options.paramName] = record.record.Id;
                    }

                    openNewWindow('POST', newURL, postData, '_blank');
                    break;
                  }
       						
       					case 'Javascript':
       					
       						frameworkAction.ActionValue.call(this, {
       							button: $button,
			            		records: [record]
			            	});
		            	break;
            	
            			default:
            			break;
       				}
            	}

            	//stop the click from getting to the map
                e.stopPropagation();
            });

			//done setting up action buttons.  fire any ready functions that are attached to them
		    $tooltipContent.find('.layout-tooltip .actionbutton').each(function () {
		        var $button = $(this);
		        var frameworkAction = $button.attr('data-type') == 'Custom Action'
					? MAActionFramework.customActions[$button.attr('data-action')] || null
					: MAActionFramework.standardActions[$button.attr('data-action')] || null;
		        
		        if (frameworkAction) {
		            if (frameworkAction.events && frameworkAction.events['ready']) {
		                $.each(frameworkAction.events['ready'], function (index, method) {
		                    method.call(this, {
		                        button  : $button,
		                        record  : record,
		                        marker  : record.marker,
		                        mode    : 'Desktop'
		                    }); 
		                });
		            }
		        }
		    });
            
            //adjust pan
            MA.Map.InfoBubble.adjust();
        }
        
        //format for user locale pass it a type or an actual date
        function formatUserLocaleDate (options)
        {
        	//grab salesforce user locale object (capitalize dates for easy modification)
        	var returnFormat;
        	
        	//format the locale for proper use
   			if(options.moment == true)
   			{
   				//moment formating (DD/MM/YYYY HH:mm, MM-DD-YYYY h:mm a, etc...)
   				returnFormat = dateTimeFormat.replace('yyyy','YYYY').replace(/d/g,'D');
   			}
   			else if (options.datepicker == true)
   			{
   				//date picker format (dd/mm/yy, mm-dd-yy, etc...)
   				returnFormat = dateFormat.replace('yyyy','yy');
   				//check for 'M' or 'MM'
   				if(dateFormat.indexOf('MM') >= 0)
   				{
   					returnFormat = returnFormat.replace('MM','mm');
   				}
   				else
   				{
   					returnFormat = returnFormat.replace('M','mm');
   				}
   				
   				//check for 'd' or 'dd'
   				if(dateFormat.indexOf('dd') <= -1)
   				{
   					returnFormat = returnFormat.replace('d','dd');
   				}
   			}
   			else if (options.salesforce == true)
   			{
   				//already in sForce format
   				returnFormat = dateTimeFormat;
   			}
   			else if (options.date)
   			{
   				//replace date format with actual date
   				returnFormat = dateTimeFormat.replace('y.', 'y').replace('M.', '').replace('d.', '').replace(/M/g, '').replace(/\//g, '').replace(/-/g,'').replace(/d/g, '').replace('yyyy', options.date)
   			}
        	return returnFormat;
        }
        
        function extractTooltipValue(tooltipMetadata, record, noLinks)
        {
            //console.log(tooltipMetadata);
            //console.log(record);
            //console.log(noLinks);
            
        	if (tooltipMetadata && record)
        	{
        		//default options
        		noLinks = noLinks || false;
        		
        		var options = {currency : userSettings.userCurrency != null ? userSettings.userCurrency : '$', precision: 2};
        		try {
        			var key = Object.keys(record.plottedQuery.data('markerMetadata').ColorAssignments)[0];
        			options.precision = key.indexOf('.') == -1 ? 2 : key.length - key.indexOf('.') - 1; 
        		}
        		catch (err) { }
        	
	        	//figure out the tooltip value
				var tooltipValue = tooltipMetadata.Accessible ? '' : 'Insufficient Privileges';
	           	var tooltipRefId;
	       		if (tooltipMetadata.Accessible && tooltipMetadata.FieldName != null)
	   			{
	   				//is this a reference field?
		           	if (tooltipMetadata.FieldName.indexOf(".") > -1)
		           	{
		               	//yes, so split on the dot and make the value a link
		               	if (record.record[tooltipMetadata.FieldName.split(".")[0]] != null)
		               	{
							var fieldParts = tooltipMetadata.FieldName.split(".");
		                   	tooltipValue = record.record[tooltipMetadata.FieldName.split(".")[0]][tooltipMetadata.FieldName.split(".")[1]];
		                   	
		                   	if(!noLinks)
		                   	{
			                   	tooltipRefId = record.record[tooltipMetadata.RefFieldName.split(".")[0]][tooltipMetadata.RefFieldName.split(".")[1]];   
			                   	tooltipValue = '<a target="_blank" href="/' + tooltipRefId + '">' + tooltipValue + '</a>';
			                }
		               	}
		           	}
		           	else
		           	{
		           		//no, so just get the data
		               	tooltipValue = record.record[tooltipMetadata.FieldName];
		           	}
		           	
		           	//formatting for boolean values
		           	if (tooltipMetadata.DisplayType == 'BOOLEAN' && tooltipValue == "")
		           	{
		           		tooltipValue = 'False';
		           	}
		           	
		           	//check for multiple currency support
		           	if(userSettings.userCurrencyuserSettings && userSettings.userCurrencyuserSettings.userCurrency) {
		           		
		           		//compare conversion rates to record
		           		var conversionRate;
		           		
		           		$.each(userSettings.currency, function (index,currency) {
		           			//convert values to user currency settings
		           			var userConverstionRate = userSettings.userConverstionRate;
		           			if(currency.IsoCode == record.record.CurrencyIsoCode && userSettings.userCurrency != record.record.CurrencyIsoCode)
		           			{
		           				conversionRate = currency.ConversionRate/userConverstionRate;
		           			}
		           		});
		           		
		           		//build options
		           		$.extend(options, {
		           			currency 			: record.record.CurrencyIsoCode,
		           			conversionRate		: conversionRate
			        	});
		           	}
		           	
		            //if we have a tooltip value, format it
		           	if (tooltipValue != "")
		           	{
		           		if (noLinks)
		           		{
			               	//we have special formatting for certain field types (i think this is redoing some of the work above and can be cleaned up a bit)
				           	if (tooltipMetadata.DisplayType == 'URL')
				           	{
				           		tooltipValue = record.record[tooltipMetadata.FieldName];
				           	}
				           	else if (tooltipMetadata.DisplayType == 'REFERENCE')
				           	{
				           		tooltipValue = record.record[tooltipMetadata.FieldName.split(".")[0]][tooltipMetadata.FieldName.split(".")[1]];
				           	}
				           	else if (tooltipMetadata.DisplayType == 'BOOLEAN')
				           	{
								tooltipValue = record.record[tooltipMetadata.FieldName] ? 'True' : 'False';			           	
							}
				           	else
				           	{
				           		tooltipValue = FormatsObjectValue(tooltipValue, tooltipMetadata.DisplayType, tooltipRefId, options);
				           	}
				        }
				        else
				        {
				        	tooltipValue = FormatsObjectValue(tooltipValue, tooltipMetadata.DisplayType, tooltipRefId, options);
				        }
		           	}
		       	}
		       	
		       	//return the value
		       	return tooltipValue;
		    }
		    
		    //just return blank if we weren't passed the proper data
		    return '';
        }
        
        //this is metadata that will be used to render and edit tooltips properly
        var displayTypeMetadata = {
        	'STRING': {
        		editType	: 'string',
        		renderType	: 'text'
        	},
        	'EMAIL': {
        		editType	: 'string',
        		renderType	: 'text'
        	},
        	'PHONE': {
        		editType	: 'string',
        		renderType	: 'text'
        	},
        	'URL': {
        		editType	: 'string',
        		renderType	: 'html'
        	},
        	'DOUBLE': {
        		editType	: 'number',
        		renderType	: 'text'
        	},
        	'CURRENCY': {
        		editType	: 'number',
        		renderType	: 'text'
        	},
        	'TEXTAREA': {
        		editType	: 'textarea',
        		renderType	: 'text'
        	},
        	'PICKLIST': {
        		editType	: 'picklist',
        		renderType	: 'text'
        	},
        	'MULTIPICKLIST': {
        		editType	: 'multipicklist',
        		renderType	: 'text'
        	},
        	'BOOLEAN': {
        		editType	: 'boolean',
        		renderType	: 'text'
        	},
        	'REFERENCE': {
        		editType	: 'reference',
        		renderType	: 'html'
        	},
        	'DATE': {
        		editType	: 'date',
        		renderType	: 'text'
        	},
        	'DATETIME': {
        		editType	: 'datetime',
        		renderType	: 'text'
        	}
        };
        
        
        	
		//display datapoints on cluster click
		function cluster_Click(cluster)
        {
            //create the tooltip content
            var clusterer = this;
            var childMarkers = cluster.getMarkers();
            
            //console.log(childMarkers);
            var SortedListOfClusterMarkers = MergeAndSort(childMarkers);
            //console.log(largeList);
            
            var $tooltipContent = $('#templates .standard-cluster-tooltip').clone();
            $tooltipContent.find('.standard-cluster-header').html(childMarkers.length + ' Record(s)');

            //create popup
        	MA.Map.InfoBubble.show({
		 		position: cluster.getCenter(),
		 		minWidth: 420,
		 		content: $tooltipContent.get(0)
		 	});
			
            //if we ended up with more than the maximum allowed records, disable the Show All Markers button
            if (childMarkers.length > 100) {
            	$tooltipContent.find('td.showallmarkers button').addClass('btnDisabled').attr({ 'disabled': 'disabled', 'title': 'Cluster must have less than 100 records' });
            }
            
            //remove the draw polygon button if we're on mobile
            if (window.location.href.toLowerCase().indexOf('mapanythingmobile') != -1) {
            	$tooltipContent.find('td.drawpolygon').remove();
            }
            
            //handle clicking buttons
            $tooltipContent.find('button').on('click', function () {
            	MA.Map.InfoBubble.hide();
	           	if ($(this).text() == "{!$Label.MA_Zoom_To_Markers}") {
	           		MA.map.fitBounds(cluster.getBounds());
	           	}
	           	else if ($(this).text() == "{!$Label.MA_Draw_Polygon}") {
	           		var shapeMgr = new MA.Map.ShapeManager();
	           		var bounds = new google.maps.LatLngBounds();
	           		$.each(childMarkers, function (i, marker) {
	           			shapeMgr.addLayer(marker.getPosition());
	           			bounds.extend(marker.getPosition());
	           		});

	           		var $proxLayer = addProximityLayer();

	           		//qid for ListView		
					var qid = $proxLayer.data('qid');

					$proxLayer.find('.proximitytype').val('Polygon').change();
					$proxLayer.data(
						'proxObject', 
						new google.maps.Polygon({
							map: MA.map,
							paths: shapeMgr.getConvexHull(),
							strokeColor: '#000000',
							strokeWeight: 4,
							fillColor: '#22CC22',
							fillOpacity: 0.6,
							layerType: 'prox',
							qid: qid
						})
					);
					$proxLayer.find('.link.showoptions').click();
					ChangeVisibilityWhenCircleIsAdded();
					MA.map.fitBounds(bounds);

					//handle shape events
					google.maps.event.addListener($proxLayer.data('proxObject'), 'click', function (e) {
                        proximityLayer_Click({ position: e.latLng, type: 'polygon', shape: $proxLayer.data('proxObject') });
                    });
                    google.maps.event.addListener($proxLayer.data('proxObject'), 'rightclick', function (e) {
                        Shape_Context.call(this, e);
                    });
	           	}
           	});

           	//loop over the child markers and create legends for each query that is represented by this cluster
           	var $contentWrapper = $tooltipContent.find('.standard-cluster-content-wrapper');
           	var recordCount = 0;
           	$.each(SortedListOfClusterMarkers, function (index, marker) {
           		try {
           			
           			//find or create the content section for this query
           			var $plottedQuery = marker.record.plottedQuery;
           			var $contentSectionHeader = $contentWrapper.find('.content-section-header.aggregates[data-query="'+$plottedQuery.data('id')+'"]');
           			var $contentSection = $contentWrapper.find('.content-section.aggregates[data-query="'+$plottedQuery.data('id')+'"]');
           			var $recordSectionHeader = $contentWrapper.find('.content-section-header.records[data-query="'+$plottedQuery.data('id')+'"]');
           			var $recordSection = $contentWrapper.find('.content-section.records[data-query="'+$plottedQuery.data('id')+'"]');
           			var $legend = $contentSection.find('.legend');
           			var advancedOptions = $plottedQuery.data('advancedOptions') || {};
           			if ($contentSection.length == 0) {
           			
           				//create aggregate section
           				$contentSectionHeader = $("<div class='content-section-header aggregates' />").attr('data-query', $plottedQuery.data('id')).text($plottedQuery.data('savedQueryName')).data('numMarkers', 0).appendTo($contentWrapper);
           				$contentSection = $("<div class='content-section aggregates'><table class='aggregates' style='width:100%;margin-bottom:10px;'></table></div>").attr({
           					'data-query': $plottedQuery.data('id')
           				}).appendTo($contentWrapper);
           				
           				//create record section
           				$recordSectionHeader = $("<div class='content-section-header records' />").attr('data-query', $plottedQuery.data('id')).text($plottedQuery.data('savedQueryName') + ' - Records').data('numMarkers', 0).appendTo($contentWrapper);
           				$recordSection = $("<div class='content-section records'><table class='records' style='width:100%;margin-bottom:10px;'></table></div>").attr({
           					'data-query': $plottedQuery.data('id')
           				}).appendTo($contentWrapper);
           				
           				//add a placeholder for aggregate information to this section
           				var aggregateType = advancedOptions.aggregateType || '';
           				var aggregates = [];
           				$.each($plottedQuery.data('tooltips'), function (index, tooltip) {
							if (tooltip.DisplayType == 'DOUBLE' || tooltip.DisplayType == 'INTEGER' || tooltip.DisplayType == 'CURRENCY') {
								aggregates.push({
									label			: tooltip.FieldLabel,
									field			: tooltip.FieldName,
									displayType		: tooltip.DisplayType,
									aggregateType	: aggregateType,
									value			: 0
								});
							}
						});
           				$contentSection.data({ aggregates: aggregates, aggregateType: aggregateType });
           				
           				//create the legend for this query if needed
           				if ($plottedQuery.data('markerMetadata').ColorAssignmentType == 'Dynamic, Field') {
	           				$legend = $plottedQuery.find('.legend').clone().hide();

	           				//fix for duplicate id styling problems of svgs (using svg defs > * to get linearGradient because jQuery won't recognize it directly)
	           				$legend.find('svg defs > *, svg circle, svg path').each(function () {
	           					var fill = $(this).attr('fill');
	           					var id = $(this).attr('id');
	           					if (fill && fill.indexOf('url') == 0) {
	           						$(this).attr('fill', fill.replace(/\)/g, '') + '_c' + ')');
	           					}
	           					if (id) {
	           						$(this).attr('id', id + '_c');
	           					}
	           				});
	           				$legend.appendTo($contentSection);
	           				
	           				$legend.find('.legend-row').data('numMarkers', 0);
	           				$legend.prepend('<tr><td colspan="5" style="color: #AFAFAF;padding: 5px 0;font-weight: bold;font-style: italic;">Legend</td></tr>');
	           			}
           			}
           			
           			//update the marker count for this query
           			$contentSectionHeader.data('numMarkers', $contentSectionHeader.data('numMarkers') + 1);
           			
           			//update the marker count for the appropriate legend row if this marker has one
           			if (marker.record.legendRow) {
           				var $legendRow = $legend.find('.legend-row').eq(marker.record.legendRow.index());
           				$legendRow.data('numMarkers', parseInt($legendRow.data('numMarkers')) + 1);
           			}
           			
           			//update the value of each aggregate
           			$.each($contentSection.data('aggregates'), function (index, aggregate) {
						aggregate.value += isNaN(parseFloat(marker.record.record[aggregate.field])) ? 0 : parseFloat(marker.record.record[aggregate.field]);
					});

					//add this record to the record section
					if (recordCount < 100) {
						var $row = $('<tr class="records-row"><td class="title" style="color: blue; cursor: pointer;"></td><td class="marker-icon" style="text-align: center;"></td></tr>');
						$row.find('.title').text(marker.title).click(function (e) { marker_Click.call(marker); e.stopPropagation(); });
						if (marker.record.legendRow) {
							if (marker.record.legendRow.find('.legend-color').is('.image')) {
								$row.find('.marker-icon').html(marker.record.legendRow.find('.legend-color').html());
							}
							else {
								$row.find('.marker-icon').html(MA.Marker.createSVG({ color: marker.record.legendRow.find('.legend-color').attr('data-color'), forLegend: true }));
							}
						}

						$recordSection.find('.records').append($row);
						recordCount++;
					}
                    
                    /*
					//sort the records section - no need for this anymore since we sort the markers via MergeAndSort()
					$recordSection.find('.records .records-row').sortElements(function (a,b) {
						return $(a).find('.title').text() > $(b).find('.title').text() ? 1 : -1;
					});
					*/
					
           		}
           		catch (err) {
           			//this should just mean that this marker does not belong to a saved query
           		}
           	});
           	
           	//remove the components that we don't need (empty legend rows, legend checkboxes)
           	$contentWrapper.find('.legend-checkbox').remove();
           	$contentWrapper.find('.legend-row').each(function () {
           		if ($(this).data('numMarkers') == 0) {
           			$(this).addClass('remove');
           		}
           	});
           	$contentWrapper.find('.legend-row.remove').remove();
           	$contentWrapper.find('.content-section.records .records').each(function () {
           		if ($(this).find('.records-row').length == 100) {
           			$(this).append('<tr><td style="color: #757575; font-size: 11px; font-style: italic;" >Only 100 markers are displayed.  Please zoom in to access additional records.</td></tr>');	
           		}
           	});
           	
           	//update the marker counts for each legend row
           	$contentWrapper.find('.legend-row').each(function () {
           		$(this).find('.visiblemarkers').text($(this).data('numMarkers'));
           	});
           	
           	//style the legends a bit to keep the counts together
           	$contentWrapper.find('.legend-row').find('td.visiblemarkers, td.of, td.totalmarkers').css({
				'width': '1px',
				'white-space': 'nowrap'
			}).filter('td.totalmarkers').css('padding-right', 30);
			
           	//accordion the sections (this is handled a bit differently on mobile vs desktop)
           	if (window.location.href.toLowerCase().indexOf('mapanythingmobile') != -1)
           	{
           		//add the marker counts to each section
	           	$contentWrapper.find('.content-section-header').each(function () {
	           		$(this).css({'position': 'relative', 'border-bottom': '1px solid black', 'padding-bottom': '3px'});
	           		$('<div style="position:absolute; top: 5px; right: 5px; font-size: 10px;" />').text($(this).data('numMarkers')).appendTo($(this));
	           	});
           	}
           	else {
           		$contentWrapper.accordion({ header: '.content-section-header', heightStyle: 'content', activate: function () { MA.Map.InfoBubble.adjust(); } });
           		
           		//add the marker counts to each section
	           	$contentWrapper.find('.content-section-header.aggregates').each(function () {
	           		$('<div style="position:absolute; top: 5px; right: 5px; color: white; font-size: 10px;" />').text($(this).data('numMarkers')).appendTo($(this));
	           	});
           	}
           	
           	//add the aggregates to each section
           	function formatAggregateValue(aggregate, numMarkers)
			{
				//if this is an avg aggregate, divide the total by the number of markers
				if (aggregate.aggregateType == 'avg') {
					aggregate.value = numMarkers == 0 ? 0 : aggregate.value / numMarkers;
				}
			
				//if this is a currency field, format the value
				if (aggregate.displayType == 'CURRENCY')
				{
					var c = 2, d = '.', t = ',';
					var n = aggregate.value, 
					    c = isNaN(c = Math.abs(c)) ? 2 : c, 
					    d = d == undefined ? "." : d, 
					    t = t == undefined ? "," : t, 
					    s = n < 0 ? "-" : "", 
					    i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + "", 
					    j = (j = i.length) > 3 ? j % 3 : 0;
					return '$' + s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
				}
				
				//return the value
				return aggregate.value;
			}
           	$contentWrapper.find('.content-section.aggregates').each(function () {
           	
           		var $section = $(this);
           		if ($section.data('aggregateType') != '') {
	           		$.each($(this).data('aggregates'), function (index, agg) {
	           			var $aggRow = $('<tr><td class="label"></td><td class="value"></td></tr>');
	           			$aggRow.find('.label').text(agg.label);
	           			$aggRow.find('.value').text(formatAggregateValue(agg, $section.prev().data('numMarkers')));
	           			$aggRow.appendTo($section.find('.aggregates'));
	           		});
	           	}
           		
           		//remove the aggregates table if it's blank.  put a header if it's not
           		if ($section.find('.aggregates tr').length == 0) { 
           			$section.find('.aggregates').remove(); 
           		}
           		else {
           			$section.find('.aggregates').prepend('<tr><td colspan="2" style="color: #AFAFAF;padding: 5px 0;font-weight: bold;font-style: italic;">Aggregates ('+$section.data('aggregateType')+')</td></tr>');
           		}
           	});
           	
           	//add some help text for sections that have no data
			$contentWrapper.find('.content-section.aggregates').each(function () {
				if ($(this).html() == '') {
					$(this).html('<div style="color:#757575;font-size:10px;font-style:italic;">Use a legend query or add numeric tooltips for additional information.</div>');
				}
			});
           	
           	//show the legends
           	$contentWrapper.find('.legend').show();
        }
        
        //Array Merge and Sort Helper Methods
        function MergeAndSort(array) 
        {
            var len = array.length;

            if(len < 2) 
            { 
                return array;
            }
            else
            {
                var pivot = Math.ceil(len/2);
                return merge(MergeAndSort(array.slice(0,pivot)), MergeAndSort(array.slice(pivot)));
            }
        }
    
        function merge(left, right)
        {
            var result = [];
            while((left.length > 0) && (right.length > 0))
            {
                if(left[0].title < right[0].title) 
                {
                    result.push(left.shift());
                }
                else 
                {
                    result.push(right.shift());
                }
            }
    
            result = result.concat(left, right);
            return result;
        };
        
        
	</script>
</apex:component>